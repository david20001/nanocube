/*
BEGIN_TODO
# 2017-03-29T17:43
Implemet locate support filtering

# 2017-03-29T17:43
Implement the not feature key value filtering

# 2017-04-04T14:00 (FIXED)
Error on json generation on (extra commas)
http://snap.research.att.com/api/osm/snap.loc(35.863089,-78.580206).radius(1000).max(5).format('json').filter(kv('highway','residential')+kv('highway','secondary')+kv('highway','primary')+kv('highway','motorway')+kv('highway','trunk')).support(2,-1).order('locates')

# 2017-04-06T11:12
Implement an option to bring all the locates of an object when sorting by objects.
http://snap.research.att.com/api/osm/snap.loc(35.863089,-78.580206).radius(1000).max(5).format('json').filter(kv('highway','residential')+kv('highway','secondary')+kv('highway','primary')+kv('highway','motorway')+kv('highway','trunk')).support(2,-1).order('objects_all')

END_TODO
*/

/*
 * Include documentation strings.
 * NOTE: this file is automatically generated on every new
 * compilation and is not part of the repository
 */
#include "app_roadmap.c.doc"

static void
ra_service_scanner(Request *request)
{
	Print      *print   = request->print;
	op_Options *options = &request->options;

	MemoryBlock filename = { .begin=0, .end=0 };
	if (!op_Options_str(options, 1, &filename)) {
		log_cstr_("[roadmap scanner] no filename provided\n");
		return;
	}

	//
	// could do it in the memory map way
	// add to the platform a way to map a file
	//
	pt_MappedFile mapped_file = platform.open_mmap_file(filename.begin, filename.end, 1, 0);
	if (!mapped_file.mapped) {
		log_cstr_("[roadmap scanner] couldn't open of the <xml> file.\n");
		return;
	}

	nt_Tokenizer tokenizer;
	rp_initialize_tokenizer(&tokenizer, mapped_file.begin, mapped_file.begin + mapped_file.size);

	while (nt_Tokenizer_next(&tokenizer)) {
		print_clear(print);
		rp_print_token(print, &tokenizer.token);
		print_cstr(print,"\n");
		output_( print);
	}

	if (tokenizer.next_result_detail != nt_TOKENIZER_NEXT_RESULT_DONE) {
		print_clear(print);
		print_cstr(print,"No transition found!\n");
		output_( print);
	}

	platform.close_mmap_file(&mapped_file);
}

#define ra_result(type) \
	(parser.next_result == rp_Parser_NEXT_RESULT_ ## type)

static void
ra_service_parser(Request *request)
{
	Print      *print   = request->print;
	op_Options *options = &request->options;

	MemoryBlock filename = { .begin=0, .end=0 };
	if (!op_Options_str(options, 1, &filename)) {
		log_cstr_("[roadmap scanner] no filename provided\n");
		return;
	}

	//
	// could do it in the memory map way
	// add to the platform a way to map a file
	//

	pt_MappedFile mapped_file = platform.open_mmap_file(filename.begin, filename.end, 1, 0);
	if (!mapped_file.mapped) {
		log_cstr_("[roadmap parser] couldn't open of the <xml> file.\n");
		return;
	}


	pt_Memory *parser_memory = platform.allocate_memory(Megabytes(32), 0);
	LinearAllocator parser_linear_allocator;
	LinearAllocator_init(&parser_linear_allocator,
			     OffsetedPointer(parser_memory->base, 0),
			     OffsetedPointer(parser_memory->base, 0),
			     OffsetedPointer(parser_memory->base, parser_memory->size));
	rp_Parser parser;
	rp_Parser_init(&parser, &parser_linear_allocator);
	rp_Parser_reset(&parser, mapped_file.begin, mapped_file.begin + mapped_file.size);

	u64 num_elements = 0;
	s32 depth        = 0;
	while (rp_Parser_next(&parser)) {

		rp_Element *element = rp_Parser_top_element(&parser);

		if (ra_result(OPEN) || ra_result(OPEN_CLOSE)) {
			print_clear(print);
			print_char(print, ' ');
			print_align(print,8 * depth,-1,' ');
			print_str(print, element->tag.begin, element->tag.end);
			print_cstr(print,"\n");
			output_(print);
		}
		if (ra_result(OPEN)) {
			++depth;
			++num_elements;
		}
		if (ra_result(OPEN_CLOSE)) {
			++num_elements;
		}
		if (ra_result(CLOSE)) {
			--depth;
		}
// 		print_clear(print);
// 		print_str(print, element->tag.begin, element->tag.end);
// 		print_cstr(print,"  line: ");
// 		print_u64(print,parser.tokenizer.line);
// 		print_cstr(print,"\n");
// 		output_( print);
	}

	print_clear(print);
	print_cstr(print,"#elements: ");
	print_s64(print,num_elements);
	print_cstr(print,"\n");
	output_( print);

	if (parser.error) {
		print_clear(print);
		print_cstr(print,"there was an error: line ");
		print_u64(print,parser.tokenizer.line);
		print_cstr(print,"\n");
		output_( print);
	}

	platform.free_memory(parser_memory);
	platform.close_mmap_file(&mapped_file);
}

/*
 * each thread has its own ra_TmpObject, when it is fully loaded,
 * it should swap with the main queue of ra_TmpObject
 */
typedef struct {
	u64  id;

	u32  type:  16;

	u32  ready: 16;

	rp_Element *element;

	/*
	 * store a sequence of pairs of MemoryBlock on
	 * the left side of the bilinear allocator and
	 * the string content on its right
	 */
	BilinearAllocator key_value_store;

	struct {
		MemoryBlock* begin;
		MemoryBlock* end;
	} key_value_pairs;

	struct {
		u64 *begin;
		u64 *end;
		u64 *capacity;
	} nodes;
} ra_TmpObject;

static void
ra_TmpObject_clear(ra_TmpObject *self)
{
	self->id      = 0;
	self->element = 0;
	self->type    = rg_OBJECT_UNDEFINED;
	self->ready   = 0;

	BilinearAllocator_clear(&self->key_value_store);
	self->key_value_pairs.end = self->key_value_pairs.begin;

	self->nodes.end = self->nodes.begin;
}

/*
 * Swap intended to be used on a delicate synchronization
 * context. We assuming this procedure is called after
 * a producer successfully reserves a slot visible by the
 * single consumer thread. The consumer thread can only
 * start working on this after it is ready.
 */
static void
ra_TmpObject_swap(ra_TmpObject *self, ra_TmpObject *other)
{
	/* should only swap when no element associated */
	Assert(self->element == other->element && self->element == 0);
	Assert(self->ready == 0 && other->ready == 0);

#define ra_TmpObject_swap_aux(field_name, field_type) \
	{ \
	field_type aux = self->field_name; \
	self->field_name = other->field_name; \
	other->field_name = aux;\
	}
	ra_TmpObject_swap_aux(id, u64);
	ra_TmpObject_swap_aux(type, u32);
	ra_TmpObject_swap_aux(key_value_store, BilinearAllocator);
	ra_TmpObject_swap_aux(key_value_pairs.begin, MemoryBlock*);
	ra_TmpObject_swap_aux(key_value_pairs.end, MemoryBlock*);
	ra_TmpObject_swap_aux(nodes.begin, u64*);
	ra_TmpObject_swap_aux(nodes.end, u64*);
	ra_TmpObject_swap_aux(nodes.capacity, u64*);

	pt_memory_barrier();

	/* now consumer is ready to do its job */
	self->ready = 1;
}

static void
ra_TmpObject_init(ra_TmpObject *self, char *key_value_buffer_begin, char *key_value_buffer_capacity,
	       u64 *nodes_begin, u64 *nodes_capacity)
{
	self->id      = 0;
	self->element = 0;
	self->type    = rg_OBJECT_UNDEFINED;
	self->ready   = 0;

	BilinearAllocator_init(&self->key_value_store, key_value_buffer_begin, key_value_buffer_capacity - key_value_buffer_begin);
	self->key_value_pairs.begin = (MemoryBlock*) key_value_buffer_begin;
	self->key_value_pairs.end   = self->key_value_pairs.begin;

	self->nodes.begin    = nodes_begin;
	self->nodes.end      = nodes_begin;
	self->nodes.capacity = nodes_capacity;

	ra_TmpObject_clear(self);
}

static b8
ra_TmpObject_insert_key_value(ra_TmpObject *self, char *key_begin, char *key_end, char *value_begin, char *value_end)
{
	s64 n_key   = key_end - key_begin;
	s64 n_value = value_end - value_begin;

	if (BilinearAllocator_free_space(&self->key_value_store) < n_key + n_value + 2 * sizeof(MemoryBlock)) {
		return 0;
	}

	char *key_buffer = BilinearAllocator_alloc_right(&self->key_value_store, n_key);
	pt_copy_bytesn(key_begin, key_buffer, n_key);

	char *value_buffer = BilinearAllocator_alloc_right(&self->key_value_store, n_value);
	pt_copy_bytesn(value_begin, value_buffer, n_value);

	MemoryBlock *key   = (MemoryBlock*) BilinearAllocator_alloc_left(&self->key_value_store, 2*sizeof(MemoryBlock));
	MemoryBlock *value = key + 1;

	key->begin = key_buffer;
	key->end   = key_buffer + n_key;

	value->begin = value_buffer;
	value->end   = value_buffer + n_value;

	self->key_value_pairs.end += 2;

	return 1;
}

static void
ra_TmpObject_set_id(ra_TmpObject *self, u64 id, rp_Element *element)
{
	self->id = id;
	self->element = element;
}

static void
ra_TmpObject_set_type(ra_TmpObject *self, u8 type)
{
	self->type = type;
}

static void
ra_TmpObject_insert_node(ra_TmpObject *self, u64 node)
{
	Assert(self->nodes.end < self->nodes.capacity);
	*self->nodes.end = node;
	++self->nodes.end;
}

static u32
ra_TmpObject_num_nodes(ra_TmpObject *self)
{
	return (u32) (self->nodes.end - self->nodes.begin);
}

static b8
ra_match(MemoryBlock memory_block, char *cstr)
{
	return (cstr_compare_memory_cstr(memory_block.begin, memory_block.end, cstr) == 0);
}

/* quotes find */
static b8
ra_find_key_value_u64(rp_KeyValue *first, char *cstr, u64 *output)
{
	/* find id from element kv map */
	rp_KeyValue *it = first;
	while (it) {
		if (ra_match(it->key, cstr)) {
			/* with quotes */
			if (pt_parse_u64(it->value.begin, it->value.end, output)) {
				return 1;
			} else {
				return 0;
			}
		}
		it = it->next;
	}
	return 0;
}

/* quotes find */
static b8
ra_find_key_value_f32(rp_KeyValue *first, char *cstr, f32 *number)
{
	/* find id from element kv map */
	rp_KeyValue *it = first;
	while (it) {
		if (ra_match(it->key, cstr)) {
			/* with quotes */
			if (pt_parse_f32(it->value.begin, it->value.end, number)) {
				return 1;
			} else {
				return 0;
			}
		}
		it = it->next;
	}
	return 0;
}

/* quoted find value */
static b8
ra_find_key_value_str(rp_KeyValue *first, char *cstr, MemoryBlock *result)
{
	/* find id from element kv map */
	rp_KeyValue *it = first;
	while (it) {
		if (ra_match(it->key, cstr)) {
			result->begin = it->value.begin;
			result->end   = it->value.end;
			return 1;
		}
		it = it->next;
	}
	return 0;
}



static u8
ra_highway_type_from_name(MemoryBlock memory_block)
{
#define ra_pattern(name) \
	(ra_match(memory_block, #name)) { return rg_OBJECT_ ## name; }
	if ra_pattern(motorway)
	else if ra_pattern(trunk)
	else if ra_pattern(primary)
	else if ra_pattern(secondary)
	else if ra_pattern(tertiary)
	else if ra_pattern(unclassified)
	else if ra_pattern(residential)
	else if ra_pattern(service)
	else if ra_pattern(motorway_link)
	else if ra_pattern(trunk_link)
	else if ra_pattern(primary_link)
	else if ra_pattern(secondary_link)
	else if ra_pattern(tertiary_link)
	else if ra_pattern(living_street)
	else if ra_pattern(pedestrian)
	else if ra_pattern(track)
	else if ra_pattern(bus_guideway)
	else if ra_pattern(escape)
	else if ra_pattern(raceway)
	else if ra_pattern(road)
	else if ra_pattern(footway)
	else if ra_pattern(bridleway)
	else if ra_pattern(steps)
	else if ra_pattern(path)
	else return rg_OBJECT_UNDEFINED;
#undef ra_pattern
}

static void
ra_print_object(Print *print, rg_Object *object)
{
	rg_Tag *tags = rg_Ptr_Tag_get(&object->tags.begin);
	for (s32 i=0;i<object->tags.count;++i) {
		rg_String *key   = rg_Ptr_String_get(&tags[i].key);
		rg_String *value = rg_Ptr_String_get(&tags[i].value);
		print_cstr(print, "...................... ");
		print_str(print,&key->begin, &key->begin + key->length);
		print_align(print, 40, -1, ' ');
		print_str(print,&value->begin, &value->begin + value->length);
		print_cstr(print,"\n");
	}
}

static void
ra_service_print(Request *request)
{
	Print      *print   = request->print;
	op_Options *options = &request->options;

	MemoryBlock filename = { .begin=0, .end=0 };
	if (!op_Options_str(options, 1, &filename)) {
		log_cstr_("[ra_latlon] no filename provided\n");
		return;
	}

	//
	// could do it in the memory map way
	// add to the platform a way to map a file
	//
	pt_MappedFile mapped_file = platform.open_mmap_file(filename.begin, filename.end, 1, 0);
	if (!mapped_file.mapped) {
		log_cstr_("[xml] couldn't open of the <xml> file.\n");
		return;
	}

	al_Allocator* allocator = (al_Allocator*) mapped_file.begin;
	rg_Graph *graph = (rg_Graph*) al_Ptr_char_get(&allocator->root_p);


	rbt_Iter iter;
	rbt_Iter_init(&iter, &graph->locates);
	u64  key    = 0;
	char *value = 0;
	u64  index  = 0;
	while (rbt_Iter_next(&iter, &key, &value)) {
		++index;

		rg_Object *way = (rg_Object*) value;

		print_clear(print);
		print_cstr(print,"[");
		print_u64(print,index);
		print_align(print, 16, 1, ' ');
		print_cstr(print,"] ");

		ra_print_object(print, way);

		output_( print);
	}

	platform.close_mmap_file(&mapped_file);

}

static void
ra_service_latlon(Request *request)
{
	Print      *print   = request->print;
	op_Options *options = &request->options;

	MemoryBlock filename = { .begin=0, .end=0 };
	if (!op_Options_str(options, 1, &filename)) {
		log_cstr_("[ra_latlon] no filename provided\n");
		return;
	}

	//
	// could do it in the memory map way
	// add to the platform a way to map a file
	//
	pt_MappedFile mapped_file = platform.open_mmap_file(filename.begin, filename.end, 1, 0);
	if (!mapped_file.mapped) {
		log_cstr_("[xml] couldn't open of the <xml> file.\n");
		return;
	}

	al_Allocator* allocator = (al_Allocator*) mapped_file.begin;
	rg_Graph *graph = (rg_Graph*) al_Ptr_char_get(&allocator->root_p);

	print_clear(print);
	print_cstr(print,"id|lat|lon\n");
	output_( print);

	rbt_Iter iter;
	rbt_Iter_init(&iter, &graph->nodes);
	u64  key    = 0;
	char *value = 0;
	u64  index  = 0;
	while (rbt_Iter_next(&iter, &key, &value)) {
		++index;

		rg_Locate *node = (rg_Locate*) value;

		print_clear(print);
		print_u64(print,node->id);
		print_cstr(print,"|");
		print_f64(print,node->lat);
		print_cstr(print,"|");
		print_f64(print,node->lon);
		print_cstr(print,"\n");
		output_( print);
	}

	platform.close_mmap_file(&mapped_file);

}

#define ra_service_create_snap_MAX_NODES_PER_OBJECT          1000000
#define ra_service_create_snap_OBJECT_KEY_VALUE_BUFFER_SIZE  Megabytes(1)
#define ra_service_create_snap_OBJECT_QUEUE_SIZE             128
#define ra_service_create_snap_LOCATION_QUEUE_SIZE        2048
#define ra_service_create_snap_MAX_THREADS                32
#define ra_service_create_snap_MAX_INPUT_FILES            256

static void
ra_service_create_snap_error_cstr(Request *request, char *msg)
{
	log_cstr_("[ra_service_create_snap] ");
	log_cstr_(msg);
	log_cstr_("\n[ra_service_create_snap] usage: nanocube roadmap <output> <input0> <input1> <input2> ... <inputN> [-size0=<size>] [-threads=n].\n");
	return;
}

static void
ra_service_create_snap_error_print(Request *request, Print *print)
{
	log_cstr_("[ra_service_create_snap] ");
	output_( print);
	log_cstr_("\n[ra_service_create_snap] usage: nanocube roadmap <output> <input0> <input1> <input2> ... <inputN> [-size0=<size>] [-threads=n].\n");
	return;
}

/*
 * threads compete to reserve the right slot
 * by running cmp_exchange on the right counter.
 *
 * the left counter follows the right counter
 * and is cosumed by a single thread that
 * processes all ways in the buffer from left
 * to right.
 *
 * left cannot get too much behind the right
 * pointer. We assume that there can be at
 * most length - 1 valid elements in the buffer
 * so when right - left == length we are
 * done.
 *
 * As soon as right is reserved, doesn't mean
 * that the consumer thread can consume it, it
 * needs to way for a flag within the
 * left element to be turned on.
 */
typedef struct {
	ra_TmpObject      *buffer;
	u64            length;
	/* don't try to optimize access to these values */
	volatile u64   left;
	volatile u64   right;
} ra_TmpObject_Queue;


static b8
ra_TmpObject_Queue_full(ra_TmpObject_Queue *self)
{
	// Once the queue gets full, only the consumer
	// thread can make it have free slots again.
	//
	Assert(self->left <= self->right);
	// in the arithmetic module length, left == right and the queue is full
	return self->left + self->length == self->right;
}

static ra_TmpObject*
ra_TmpObject_Queue_reserve(ra_TmpObject_Queue *self)
{
	// keep trying to reserve a slot on the queue
	// so that we can push the data
	for (;;) {
		u64 slot = self->right;

		// cannot ever reserve with a full queue
		// note the we can only successfully reserve
		// "slot" if queue is not full. If queue
		// became full after we got slot, then
		// the atomic operation below will fail
		// (unless 2^64 instructions could happen
		// and somehow fold the right/left queue
		// counters.
		if (ra_TmpObject_Queue_full(self))
			return 0;

		/* keep in a busy wait if queue is full */
		u64 old_slot = pt_atomic_cmp_and_swap_u64(&self->right, slot, slot + 1);
		if (old_slot == slot) {
			return self->buffer + (slot % self->length);
		}
	}
}

static ra_TmpObject*
ra_TmpObject_Queue_head(ra_TmpObject_Queue *self)
{
	if (self->left < self->right) {
		ra_TmpObject *head = self->buffer + (self->left % self->length);
		if (head->ready) {
			return head;
		} else {
			return 0;
		}
	} else {
		return 0;
	}
}

static void
ra_TmpObject_Queue_pop_head(ra_TmpObject_Queue *self)
{
	Assert(self->left < self->right);
	ra_TmpObject *head = self->buffer + (self->left % self->length);
	Assert(head->ready);
	ra_TmpObject_clear(head);

	pt_memory_barrier();

	++self->left;
}

typedef struct {
	u64 id;
	f32 lat;
	f32 lon;
	b8  ready;
} ra_Location;

typedef struct {
	ra_Location    *buffer;
	u64            length;
	volatile u64   left;
	volatile u64   right;
} ra_Location_Queue;

static b8
ra_Location_Queue_full(ra_Location_Queue *self)
{
	// Once the queue gets full, only the consumer
	// thread can make it have free slots again.
	//
	Assert(self->left <= self->right);
	// in the arithmetic module length, left == right and the queue is full
	return self->left + self->length == self->right;
}

static ra_Location*
ra_Location_Queue_reserve(ra_Location_Queue *self)
{
	// keep trying to reserve a slot on the queue
	// so that we can push the data
	for (;;) {
		u64 slot = self->right;

		// cannot ever reserve with a full queue
		// note the we can only successfully reserve
		// "slot" if queue is not full. If queue
		// became full after we got slot, then
		// the atomic operation below will fail
		// (unless 2^64 instructions could happen
		// and somehow fold the right/left queue
		// counters.
		if (ra_Location_Queue_full(self))
			return 0;

		/* keep in a busy wait if queue is full */
		u64 old_slot = pt_atomic_cmp_and_swap_u64(&self->right, slot, slot + 1);
		if (old_slot == slot) {
			return self->buffer + (slot % self->length);
		}
	}
}

static ra_Location*
ra_Location_Queue_head(ra_Location_Queue *self)
{
	if (self->left < self->right) {
		ra_Location *head = self->buffer + (self->left % self->length);
		if (head->ready) {
			return head;
		} else {
			return 0;
		}
	} else {
		return 0;
	}
}

static void
ra_Location_Queue_pop_head(ra_Location_Queue *self)
{
	Assert(self->left < self->right);
	ra_Location *head = self->buffer + (self->left % self->length);
	Assert(head->ready);

	head->id    = 0;
	head->ready = 0;
	head->lat   = 0.0f;
	head->lon   = 0.0f;

	pt_memory_barrier();

	++self->left;
}

typedef struct {
	Request                       *request;
	rg_Graph                      *graph;
	pt_Mutex                      mutex;
	MemoryBlock                   *input_filenames;
	pt_MappedFile                 *mapped_files;
	u64                           report_frequency;
	s32                           num_threads;
	struct {
		b8 roads;
		b8 buildings;
		b8 tagged_nodes;
		b8 cells;
	} include;
	// when multi-threaded, use the records below
	struct {
		ra_TmpObject_Queue   tmpway_queue;
		ra_TmpObject         *tmpway_threads;
		ra_Location_Queue location_queue;
		u32               jobs_completed;
	} multithread;
} ra_service_create_snap_Info;

// should be initized every time we call build
static ra_service_create_snap_Info ra_service_create_snap_info;

/* the procedure below was designed to be executed by a single thread */
static void
ra_service_create_snap_insert_way(ra_TmpObject *tmp_way)
{
	rg_Graph *graph = ra_service_create_snap_info.graph;

	Assert(tmp_way->type != rg_OBJECT_UNDEFINED);
	Assert(tmp_way->ready == 1);

	static rg_Locate* nodes[ra_service_create_snap_MAX_NODES_PER_OBJECT];
	s32 num_nodes = 0;

	u64 *it = tmp_way->nodes.begin;
	while (it != tmp_way->nodes.end) {
		u64 node_id = *it;
		rg_Locate* node = rg_Graph_get_node(graph, node_id);
		if (!node) {
			node = rg_Graph_insert_node(graph, node_id);
			Assert(node);
		}
		Assert(num_nodes + 1 < ra_service_create_snap_MAX_NODES_PER_OBJECT);
		nodes[num_nodes] = node;
		++num_nodes;
		++it;
	}

	/* create way */
	rg_Object *way = rg_Graph_get_object(graph, tmp_way->id);
	if (!way) {
		way = rg_Graph_insert_locate(graph, tmp_way->id, tmp_way->key_value_pairs.begin, tmp_way->key_value_pairs.end);

		/* link way with nodes */
		rg_Graph_set_incident_locates_to_object(graph, way, nodes, nodes + num_nodes);
	} else {
		Request *request = ra_service_create_snap_info.request;
		Print* print = request->print;

		platform.lock_mutex(ra_service_create_snap_info.mutex);

		print_clear(print);
		print_format(print,"Duplicate way ID. Keeping only the 1st occurrence %llu.\n", tmp_way->id);
		output_( print);
// 		MemoryBlock *input_filename = ra_service_create_snap_info.input_filenames + input_index;
// 		print_str(print, input_filename->begin, input_filename->end);
// 		print_cstr(print, "\n");

		platform.unlock_mutex(ra_service_create_snap_info.mutex);
	}
}

/* the procedure below was designed to be executed by a single thread */
static b8
ra_service_create_snap_update_location(ra_Location *location)
{
	rg_Graph *graph = ra_service_create_snap_info.graph;
	Assert(location->ready == 1);
	rg_Locate *node = rg_Graph_get_node(graph, location->id);
	if (node) {
		node->lat = location->lat;
		node->lon = location->lon;
		return 1;
	} else {
		return 0;
	}
}




static void
ra_service_create_snap_parse_ways_single_threaded(s32 input_index)
{

	/* single threaded solution */
	pt_MappedFile* mapped_file  = ra_service_create_snap_info.mapped_files + input_index;
	Request        *request     = ra_service_create_snap_info.request;
	rg_Graph       *graph       = ra_service_create_snap_info.graph;
	Print          *print       = request->print;

	/* memory for .xml parsing */
	pt_Memory *work_memory = platform.allocate_memory(Megabytes(32), 0);
	LinearAllocator work_allocator;
	LinearAllocator_init(&work_allocator,
			     OffsetedPointer(work_memory->base,0),
			     OffsetedPointer(work_memory->base,0),
			     OffsetedPointer(work_memory->base, work_memory->size));

	/* prepare storage space for runnint tmp_way object */
	char *way_key_value_pairs_memory  = LinearAllocator_alloc(&work_allocator, ra_service_create_snap_OBJECT_KEY_VALUE_BUFFER_SIZE);
	u64  *way_nodes_memory = (u64*) LinearAllocator_alloc(&work_allocator, ra_service_create_snap_MAX_NODES_PER_OBJECT * sizeof(u64));
	ra_TmpObject tmp_way;
	ra_TmpObject_init(&tmp_way, way_key_value_pairs_memory, way_key_value_pairs_memory + ra_service_create_snap_OBJECT_KEY_VALUE_BUFFER_SIZE,
		       way_nodes_memory, way_nodes_memory + ra_service_create_snap_MAX_NODES_PER_OBJECT);

	/* from now on work_allocator becomes exclusive of the parser */
	rp_Parser parser;
	rp_Parser_init(&parser, &work_allocator);
	rp_Parser_reset(&parser, mapped_file->begin, mapped_file->begin + mapped_file->size);

	u64 num_elements      = 0;
	u64 num_objects          = 0;
	u64 num_nodes         = 0;

	while (rp_Parser_next(&parser)) {

		rp_Element *element = rp_Parser_top_element(&parser);

		b8 open  = ra_result(OPEN)  || ra_result(OPEN_CLOSE);
		b8 close = ra_result(CLOSE) || ra_result(OPEN_CLOSE);

		if (open) {
			/* new element */
			++num_elements;

			// report
			if (ra_service_create_snap_info.report_frequency && ((num_elements % ra_service_create_snap_info.report_frequency) == 0)) {
				print_clear(print);
				print_format(print, "Input %3d | Pass 1 | Elements %12llu | Objects %12llu | Nodes %12llu\n",
					     input_index, num_elements, num_objects, num_nodes);
				output_( print);
			}

			/* new way record on its way */

			/*
			   <way id="8807327" version="2" timestamp="2013-01-29T17:51:43Z" changeset="14837510" uid="451693" user="bot-mode">
			   <nd ref="63483902"/>
			   <nd ref="63483906"/>
			   <nd ref="63483908"/>
			   <tag k="name" v="Hickory Lane"/>
			   <tag k="highway" v="residential"/>
			   <tag k="tiger:cfcc" v="A41"/>
			   <tag k="tiger:county" v="Loudoun, VA"/>
			   <tag k="tiger:reviewed" v="no"/>
			   <tag k="tiger:name_base" v="Hickory"/>
			   <tag k="tiger:name_type" v="Ln"/>
			   </way>
			   */

			if (tmp_way.element) {
				/* there is a way in context */

				/* sub-element of a way object */
				if (ra_match(element->tag,"nd")) {
					/* find id from element kv map */
					u64 node_id = 0;
					if (ra_find_key_value_u64(element->kv_first, "ref", &node_id)) {
						ra_TmpObject_insert_node(&tmp_way, node_id);
					} else {
						/* if there is a node in a way without valid id invalidate all */
						ra_TmpObject_clear(&tmp_way);
					}
				} else if (ra_match(element->tag, "tag")) {

					MemoryBlock k_value = {.begin=0, .end=0};
					if (!ra_find_key_value_str(element->kv_first, "k", &k_value))
						continue;

					MemoryBlock v_value = {.begin=0, .end=0};
					if (!ra_find_key_value_str(element->kv_first, "v", &v_value))
						continue;

					/* specific filtering on the highway type */
					if (ra_service_create_snap_info.include.roads) {
						if (ra_match(k_value, "highway")) {
							u8 type = ra_highway_type_from_name(v_value);
							if (type == rg_OBJECT_UNDEFINED) {
								/* discard this way */
								ra_TmpObject_clear(&tmp_way);
							} else {
								ra_TmpObject_set_type(&tmp_way, type);
							}
						}
					}

					if (ra_service_create_snap_info.include.buildings) {
						if (ra_match(k_value, "building") /* && ra_match(v_value,"yes")*/) {
							ra_TmpObject_set_type(&tmp_way, rg_OBJECT_building);
						}
					}

					if (tmp_way.element) {
						ra_TmpObject_insert_key_value(&tmp_way, k_value.begin, k_value.end, v_value.begin, v_value.end);
					}
				}

			} else if (ra_match(element->tag,"way")) {

				/* find id from element kv map */
				u64 id = 0;
				if (ra_find_key_value_u64(element->kv_first, "id", &id)) {
					ra_TmpObject_set_id(&tmp_way, id, element);
				}

			} else if (ra_service_create_snap_info.include.cells && ra_match(element->tag,"cell") && !close) {

				/* find id from element kv map */
				u64 id = 0;
				if (ra_find_key_value_u64(element->kv_first, "id", &id)) {
					ra_TmpObject_set_id(&tmp_way, id, element);
					ra_TmpObject_set_type(&tmp_way, rg_OBJECT_cell);
				}

			} else if (ra_service_create_snap_info.include.tagged_nodes && ra_match(element->tag,"node") && !close) {

				/* find id from element kv map */
				u64 id = 0;
				if (ra_find_key_value_u64(element->kv_first, "id", &id)) {
					ra_TmpObject_set_id(&tmp_way, 1000000000000000ull + id, element);
					ra_TmpObject_set_type(&tmp_way, rg_OBJECT_tagged_node);
					/* on the second pass we update tha lat/lon */
					ra_TmpObject_insert_node(&tmp_way, id);
				}
			}
		}

		if (close && tmp_way.element == element) {

			if (tmp_way.type != rg_OBJECT_UNDEFINED && tmp_way.key_value_pairs.begin < tmp_way.key_value_pairs.end) {

				tmp_way.ready = 1;

				// update statistics for this input file
				++num_objects;
				num_nodes += tmp_way.nodes.end - tmp_way.nodes.begin;

				ra_service_create_snap_insert_way(&tmp_way);

				ra_TmpObject_clear(&tmp_way);

			} else {

				ra_TmpObject_clear(&tmp_way);

			}
		}
	}

	if (parser.error) {
		print_clear(print);
		print_format(print, "Parsing error detected on line %d column %d\n", parser.tokenizer.line, parser.tokenizer.column);
		output_( print);
		return;
	}

	print_clear(print);
	print_format(print, "Input %3d | Pass 1 | Elements %12llu | Objects %12llu | Nodes %12llu\n",
		     input_index, num_elements, num_objects, num_nodes);
	output_( print);

	/* free parsing memory */
	platform.free_memory(work_memory);
}

static void
ra_service_create_snap_parse_ways_multi_threaded(s32 input_index)
{
	Assert(ra_service_create_snap_info.num_threads > 1);

	// within the current workqueue, which thread are we
	s32 thread_index = (s32) platform.get_thread_index();

	/* single threaded solution */
	pt_Mutex       mutex        = ra_service_create_snap_info.mutex;
	pt_MappedFile* mapped_file  = ra_service_create_snap_info.mapped_files + input_index;
	Request        *request     = ra_service_create_snap_info.request;
	rg_Graph       *graph       = ra_service_create_snap_info.graph;
	Print          *print       = request->print;

	ra_TmpObject_Queue *queue = &ra_service_create_snap_info.multithread.tmpway_queue;

	/* memory for .xml parsing */
	pt_Memory *work_memory = platform.allocate_memory(Megabytes(16), 0);
	LinearAllocator work_allocator;
	LinearAllocator_init(&work_allocator,
			     OffsetedPointer(work_memory->base,0),
			     OffsetedPointer(work_memory->base,0),
			     OffsetedPointer(work_memory->base,work_memory->size));

	/* prepare storage space for runnint tmp_way object */
	Assert(thread_index < ra_service_create_snap_info.num_threads);
	ra_TmpObject *tmp_way = ra_service_create_snap_info.multithread.tmpway_threads + thread_index;
	ra_TmpObject_clear(tmp_way);
	Assert(tmp_way->ready == 0);
	Assert(tmp_way->element == 0);

	/* from now on work_allocator becomes exclusive of the parser */
	rp_Parser parser;
	rp_Parser_init(&parser, &work_allocator);
	rp_Parser_reset(&parser, mapped_file->begin, mapped_file->begin + mapped_file->size);

	u64 num_elements = 0;
	u64 num_objects     = 0;
	u64 num_nodes    = 0;

	while (rp_Parser_next(&parser)) {

		rp_Element *element = rp_Parser_top_element(&parser);

		b8 open  = ra_result(OPEN)  || ra_result(OPEN_CLOSE);
		b8 close = ra_result(CLOSE) || ra_result(OPEN_CLOSE);

		if (open) {
			/* new element */
			++num_elements;

			if (ra_service_create_snap_info.report_frequency && ((num_elements % ra_service_create_snap_info.report_frequency) == 0)) {
				platform.lock_mutex(mutex);

				print_clear(print);
				print_format(print, "Input %3d | Pass 1 | Elements %12llu | Objects %12llu | Nodes %12llu\n",
					     input_index, num_elements, num_objects, num_nodes);
				output_( print);

				platform.unlock_mutex(mutex);
			}

			/* new way record on its way */

			/*
			   <way id="8807327" version="2" timestamp="2013-01-29T17:51:43Z" changeset="14837510" uid="451693" user="bot-mode">
			   <nd ref="63483902"/>
			   <nd ref="63483906"/>
			   <nd ref="63483908"/>
			   <tag k="name" v="Hickory Lane"/>
			   <tag k="highway" v="residential"/>
			   <tag k="tiger:cfcc" v="A41"/>
			   <tag k="tiger:county" v="Loudoun, VA"/>
			   <tag k="tiger:reviewed" v="no"/>
			   <tag k="tiger:name_base" v="Hickory"/>
			   <tag k="tiger:name_type" v="Ln"/>
			   </way>
			   */

			if (tmp_way->element) {
				/* there is a way in context */

				/* sub-element of a way object */
				if (ra_match(element->tag,"nd")) {
					/* find id from element kv map */
					u64 node_id = 0;
					if (ra_find_key_value_u64(element->kv_first, "ref", &node_id)) {
						ra_TmpObject_insert_node(tmp_way, node_id);
					} else {
						/* if there is a node in a way without valid id invalidate all */
						ra_TmpObject_clear(tmp_way);
					}
				} else if (ra_match(element->tag, "tag")) {

					MemoryBlock k_value = {.begin=0, .end=0};
					if (!ra_find_key_value_str(element->kv_first, "k", &k_value))
						continue;

					MemoryBlock v_value = {.begin=0, .end=0};
					if (!ra_find_key_value_str(element->kv_first, "v", &v_value))
						continue;

					/* specific filtering on the highway type */
					if (ra_service_create_snap_info.include.roads) {
						if (ra_match(k_value, "highway")) {
							u8 type = ra_highway_type_from_name(v_value);
							if (type == rg_OBJECT_UNDEFINED) {
								/* discard this way */
								ra_TmpObject_clear(tmp_way);
							} else {
								ra_TmpObject_set_type(tmp_way, type);
							}
						}
					}

					if (ra_service_create_snap_info.include.buildings) {
						if (ra_match(k_value, "building") /* && ra_match(v_value,"yes")*/) {
							ra_TmpObject_set_type(tmp_way, rg_OBJECT_building);
						}
					}

					if (tmp_way->element) {
						ra_TmpObject_insert_key_value(tmp_way, k_value.begin, k_value.end, v_value.begin, v_value.end);
					}
				}

			} else if (ra_match(element->tag,"way")) {

				/* find id from element kv map */
				u64 id = 0;
				if (ra_find_key_value_u64(element->kv_first, "id", &id)) {
					ra_TmpObject_set_id(tmp_way, id, element);
				}

			} else if (ra_service_create_snap_info.include.cells && ra_match(element->tag,"cell") && !close) {

				/* find id from element kv map */
				u64 id = 0;
				if (ra_find_key_value_u64(element->kv_first, "id", &id)) {
					ra_TmpObject_set_id(tmp_way, id, element);
					ra_TmpObject_set_type(tmp_way, rg_OBJECT_cell);
				}

			} else if (ra_service_create_snap_info.include.tagged_nodes && ra_match(element->tag,"node") && !close) {

				/* find id from element kv map */
				u64 id = 0;
				if (ra_find_key_value_u64(element->kv_first, "id", &id)) {
					ra_TmpObject_set_id(tmp_way, 1000000000000000ull + id, element);
					ra_TmpObject_set_type(tmp_way, rg_OBJECT_tagged_node);
					/* on the second pass we update tha lat/lon */
					ra_TmpObject_insert_node(tmp_way, id);
				}
			}
		}

		if (close && tmp_way->element == element) {

			if (tmp_way->type != rg_OBJECT_UNDEFINED && tmp_way->key_value_pairs.begin < tmp_way->key_value_pairs.end) {

				ra_TmpObject *slot = 0;
				while (!slot) {
					slot = ra_TmpObject_Queue_reserve(queue);
					/*
					 * slot might come as 0 if queue is full,
					 * not sure how useful, but is should
					 * be an oportunity for this thread to
					 * calm down and sleep for a while
					 */

					if (!slot) {
						/*
						 * interestingly, if we don't slow calm
						 * down the threads here, the process gets
						 * stuck.
						 *
						 * Maybe this is related to the barriers
						 * and giving no time for cmp_swap_exchange.
						 * not sure why
						 */
						platform.thread_sleep(1);
					}
				}

				// erase reference to element. won't need it anymore.
				tmp_way->element = 0;

				++num_objects;
				num_nodes += tmp_way->nodes.end - tmp_way->nodes.begin;

				// simply swap slots
				ra_TmpObject_swap(slot, tmp_way);

				// tmp_way should now be clear and we can continue our work
			} else {
				ra_TmpObject_clear(tmp_way);
			}
		}
	}

	if (parser.error) {
		platform.lock_mutex(mutex);
		print_clear(print);
		print_format(print, "Parsing error detected on line %d column %d\n", parser.tokenizer.line, parser.tokenizer.column);
		output_( print);
		platform.unlock_mutex(mutex);
		return;
	}

	platform.lock_mutex(mutex);
	print_clear(print);
	print_format(print, "Input %3d | Pass 1 | Elements %12llu | Objects %12llu | Nodes %12llu\n",
		     input_index, num_elements, num_objects, num_nodes);
	output_( print);
	platform.unlock_mutex(mutex);

	/* free parsing memory */
	platform.free_memory(work_memory);

	/* register that job was completed */
	pt_atomic_add_u32(&ra_service_create_snap_info.multithread.jobs_completed,1);

}

static void
ra_service_create_snap_parse_nodes_multi_threaded(s32 input_index)
{
	// s32            input_index  = *((s32*) data);
	pt_Mutex          mutex        = ra_service_create_snap_info.mutex;
	pt_MappedFile*    mapped_file  = ra_service_create_snap_info.mapped_files + input_index;
	Request           *request     = ra_service_create_snap_info.request;
	rg_Graph          *graph       = ra_service_create_snap_info.graph;
	Print             *print       = request->print;

	ra_Location_Queue *queue    = &ra_service_create_snap_info.multithread.location_queue;

	/* memory for .xml parsing */
	pt_Memory *work_memory = platform.allocate_memory(Megabytes(32), 0);
	LinearAllocator work_allocator;
	LinearAllocator_init(&work_allocator,
			     OffsetedPointer(work_memory->base,0),
			     OffsetedPointer(work_memory->base,0),
			     OffsetedPointer(work_memory->base,work_memory->size));

	/* from now on work_allocator becomes exclusive of the parser */
	rp_Parser parser;
	rp_Parser_init(&parser, &work_allocator);
	rp_Parser_reset(&parser, mapped_file->begin, mapped_file->begin + mapped_file->size);

	u64 num_elements = 0;
	u64 num_nodes    = 0;

	while (rp_Parser_next(&parser)) {

		rp_Element *element = rp_Parser_top_element(&parser);

		b8 open  = ra_result(OPEN)  || ra_result(OPEN_CLOSE);

		if (open) {
			/* new element */
			++num_elements;
			if (ra_service_create_snap_info.report_frequency && ((num_elements % ra_service_create_snap_info.report_frequency) == 0)) {
				platform.lock_mutex(mutex);
				print_clear(print);
				print_format(print, "Input %3d | Pass 2 | Elements %12llu | Nodes %12llu\n", input_index, num_elements, num_nodes);
				output_( print);
				platform.unlock_mutex(mutex);
			}
		}

		if (open && ra_match(element->tag,"node")) {
			/* find id from element kv map */
			ra_Location location;
			location.ready = 0;
			if (!ra_find_key_value_u64(element->kv_first, "id", &location.id)) {
				continue;
			}
			if (!ra_find_key_value_f32(element->kv_first, "lat", &location.lat)) {
				continue;
			}
			if (!ra_find_key_value_f32(element->kv_first, "lon", &location.lon)) {
				continue;
			}

			// push into queue
			ra_Location *slot = 0;
			for (;;) {
				slot = ra_Location_Queue_reserve(queue);
				/*
				 * slot might come as 0 if queue is full,
				 * not sure how useful, but is should
				 * be an oportunity for this thread to
				 * calm down and sleep for a while
				 */

				if (!slot) {
					/*
					 * interestingly, if we don't slow calm
					 * down the threads here, the process gets
					 * stuck.
					 *
					 * Maybe this is related to the barriers
					 * and giving no time for cmp_swap_exchange.
					 * not sure why
					 */
					platform.thread_sleep(1);
				} else {
					break;
				}
			}

			// if (slot->ready) {
// 				platform.lock_mutex(mutex);
// 				print_clear(print);
// 				print_format(print, "index: %6d slot: %6lld left: %6llu  right: %6llu\n",
// 					     input_index, slot - queue->buffer, queue->left % queue->length, queue->right % queue->length);
// 				output_( print);
// 				platform.unlock_mutex(mutex);
			// }


			Assert(slot->ready == 0);
			slot->id  = location.id;
			slot->lat = location.lat;
			slot->lon = location.lon;

			pt_memory_barrier();

			slot->ready = 1;

			++num_nodes;

		}
	}

	platform.lock_mutex(mutex);
	print_clear(print);
	print_format(print, "Input %3d | Pass 2 | Elements %12llu | Nodes %12llu\n", input_index, num_elements, num_nodes);
	output_( print);
	platform.unlock_mutex(mutex);

	/* free parsing memory */
	platform.free_memory(work_memory);

	/* register that job was completed */
	pt_atomic_add_u32(&ra_service_create_snap_info.multithread.jobs_completed,1);

}


static void
ra_service_create_snap_parse_nodes_single_threaded(s32 input_index)
{
	// s32            input_index  = *((s32*) data);
	pt_MappedFile* mapped_file  = ra_service_create_snap_info.mapped_files + input_index;
	Request        *request     = ra_service_create_snap_info.request;
	rg_Graph       *graph       = ra_service_create_snap_info.graph;
	Print          *print       = request->print;

	/* memory for .xml parsing */
	pt_Memory *work_memory = platform.allocate_memory(Megabytes(32), 0);
	LinearAllocator work_allocator;
	LinearAllocator_init(&work_allocator,
			     OffsetedPointer(work_memory->base,0),
			     OffsetedPointer(work_memory->base,0),
			     OffsetedPointer(work_memory->base,work_memory->size));

	/* from now on work_allocator becomes exclusive of the parser */
	rp_Parser parser;
	rp_Parser_init(&parser, &work_allocator);
	rp_Parser_reset(&parser, mapped_file->begin, mapped_file->begin + mapped_file->size);

	u64 num_elements = 0;
	u64 num_nodes    = 0;

	while (rp_Parser_next(&parser)) {

		rp_Element *element = rp_Parser_top_element(&parser);

		b8 open  = ra_result(OPEN)  || ra_result(OPEN_CLOSE);

		if (open) {
			/* new element */
			++num_elements;
			if (ra_service_create_snap_info.report_frequency && ((num_elements % ra_service_create_snap_info.report_frequency) == 0)) {
				print_clear(print);
				print_format(print, "Input %3d | Pass 2 | Elements %12llu | Nodes %12llu \n", input_index, num_elements, num_nodes);
				output_( print);
			}
		}

		if (open && ra_match(element->tag,"node")) {
			/* find id from element kv map */
			ra_Location location;
			location.ready = 0;
			if (!ra_find_key_value_u64(element->kv_first, "id", &location.id)) {
				continue;
			}
			if (!ra_find_key_value_f32(element->kv_first, "lat", &location.lat)) {
				continue;
			}
			if (!ra_find_key_value_f32(element->kv_first, "lon", &location.lon)) {
				continue;
			}

			location.ready = 1;

			// don't think I need this memory barrier...
			pt_memory_barrier();

			ra_service_create_snap_update_location(&location);

			++num_nodes;
		}
	}

	print_clear(print);
	print_format(print, "Input %3d | Pass 2 | Elements %12llu | Nodes %12llu \n", input_index, num_elements, num_nodes);
	output_( print);

	/* free parsing memory */
	platform.free_memory(work_memory);
}


PLATFORM_WORK_QUEUE_CALLBACK(ra_service_create_snap_parse_ways_callback)
{
	s32 input_index  = *((s32*) data);
	ra_service_create_snap_parse_ways_multi_threaded(input_index);
}

PLATFORM_WORK_QUEUE_CALLBACK(ra_service_create_snap_parse_nodes_callback)
{
	s32 input_index  = *((s32*) data);
	ra_service_create_snap_parse_nodes_multi_threaded(input_index);
}


/*
BEGIN_DOC_STRING ra_service_create_snap_doc
Usage: nanocube create-snap OUTPUT *(INPUT) [-threads=N] [-report-frequency=N]
            [-roads] [-buildings] [-nodes] [-cells] [-help]
Command to build a *snap* database of *objects* based on a constrained `xml` format
used by the Open Street Maps project.

    -size0=N
        Some size that should fit the whole final .snap index and should be guessed
	correctly beforehand. @todo: improve this. Default is 4G.

    -roads
        Create object for <way ...> elements that has sub-element <tag k="highway">

    -buildings
        Create object for <way ...> elements that has sub-element <tag k="highway" ...>

    -nodes
        Create object for <node> elements that has at least one <tag> sub-element.

    -cells
        Create object for <way ...> elements that has sub-element <tag k="highway" ...>

END_DOC_STRING
*/

static void
ra_service_create_snap(Request *request)
{
	// @todo @uncomment
#if 0
	Print      *print   = request->print;
	op_Options *options = &request->options;

	if (op_Options_find_cstr(options,"-help")) {
		print_clear(print);
		print_cstr(print, ra_service_create_snap_doc);
		output_( print);
		return;
	}

	// at least one input parameter
	u32 num_ordered_params = op_Options_num_positioned_parameters(options);
	if (num_ordered_params < 3) {
		print_clear(print);
		print_cstr(print, ra_service_create_snap_doc);
		print_cstr(print, "[issue] not enough input parameters (one output filename and at least one input filename).\n");
		output_( print);
		return;
	}

	// output filename is the first ordered option
	MemoryBlock output_filename = { .begin=0, .end=0 };
	if (!op_Options_str(options, 1, &output_filename)) {
		ra_service_create_snap_error_cstr(request, "couldn't read output filename.");
		return;
	}

	s64 size0 = Gigabytes(4);
	if (op_Options_find_cstr(options,"-size0")) {
		MemoryBlock st;
		if (!op_Options_named_str_cstr(options,"-size0",0,&st)) {
			ra_service_create_snap_error_cstr(request, "invalid memory value on -size0 (default: 4G)");
			return;
		} else {
			size0 = ut_parse_storage_size(st.begin, st.end);
			if (size0 < Megabytes(4)) {
				ra_service_create_snap_error_cstr(request, "invalid memory value on -size0 (needs to be at least 4M)");
				return;
			}
		}
	}

	/*
	 * consider "way" elements that contain a tag element with
	 * <tag k="highway" ...>
	 */
	b8 roads     = 0;

	/*
	 * consider "way" elements that contain a tag element with
	 * <tag k="building" ...>
	 */
	b8 buildings = 0;

	/*
	 * consider "node" elements that contain at least one tag.
	 * register these nodes as a "way" and also insert the
	 * node. Append a long number to the node id: 10e11 + ID
	 * or something that fits within u64.
	 */
	b8 tagged_nodes = 0;

	/*
	 * consider "cell" elements
	 */
	b8 cells = 0;

	if (op_Options_find_cstr(options, "-buildings")) {
		buildings = 1;
	}

	if (op_Options_find_cstr(options, "-roads")) {
		roads     = 1;
	}

	if (op_Options_find_cstr(options, "-nodes")) {
		tagged_nodes = 1;
	}

	if (op_Options_find_cstr(options, "-cells")) {
		cells = 1;
	}

	if (!roads && !buildings && !tagged_nodes && !cells) {
		ra_service_create_snap_error_cstr(request, "Set at least one of -roads, -buildings, -nodes, -cells");
		return;
	}

	print_clear(print);
	print_format(print, "Mode: roads %d   buildings %d   tagged nodes %d   cells %d\n", roads, buildings, tagged_nodes, cells);
	output_( print);

	pt_MappedFile mapped_files[ra_service_create_snap_MAX_INPUT_FILES];
	MemoryBlock   input_filenames[ra_service_create_snap_MAX_INPUT_FILES];
	s32           input_indices[ra_service_create_snap_MAX_INPUT_FILES];
	s32 num_input_files = 0;
	for (s32 i=2;i<num_ordered_params;++i) {
		s32 index = i-2;
		MemoryBlock input_filename = { .begin = 0, .end = 0 };
		if (!op_Options_str(options, i, &input_filename)) {
			print_clear(print);
			print_format(print, "couldn't read input filename %d", index);
			print_str(print, input_filename.begin, input_filename.end);
			ra_service_create_snap_error_print(request, print);
			return;
		} else {
			input_indices[index] = index;
			input_filenames[index] = input_filename;
			mapped_files[index] = platform.open_mmap_file(input_filename.begin, input_filename.end, 1, 0);
			if (!mapped_files[index].mapped) {
				print_clear(print);
				print_format(print, "couldn't memory map input %d filename: ", index);
				print_str(print, input_filename.begin, input_filename.end);
				ra_service_create_snap_error_print(request, print);
				return;
			}
			++num_input_files;
		}
	}

	u64 num_threads = 0;
	if (op_Options_find_cstr(options,"-threads")) {
		if (!op_Options_named_u64_cstr(options,"-threads",0,&num_threads)) {
			log_cstr_("[serve] incorrect usage of options: -threads=<num-threads>\n");
			return;
		}
	}

	u64 report_frequency = 0;
	if (op_Options_find_cstr(options,"-report-frequency")) {
		if (!op_Options_named_u64_cstr(options,"-report-frequency",0,&report_frequency)) {
			log_cstr_("[serve] incorrect usage of options: -report-frequency=<num-xml-elements>\n");
			return;
		}
	}

	/*
	 * Create an arena and a Graph as its main object
	 * @TODO(llins): provide better mechanism than pre-allocating
	 * lot of RAM without any support to go beyond this initial
	 * allocated memory.
	 */
	pt_Memory *data_memory = platform.allocate_memory(size0, 0);

	al_Allocator* allocator = al_Allocator_new(OffsetedPointer(data_memory->base,0), OffsetedPointer(data_memory->base,data_memory->size));
	al_Cache *graph_cache = al_Allocator_create_cache(allocator, "rg_Graph", sizeof(rg_Graph));
	rg_Graph *graph = (rg_Graph*) al_Cache_alloc(graph_cache);

	rg_Graph_init(graph, allocator);

	// set root object of the allocator as the new empty nanocube
	al_Ptr_char_set(&allocator->root_p, (char*) graph);

	pt_Mutex mutex = platform.create_mutex();

	ra_service_create_snap_info = (ra_service_create_snap_Info) {
		.request = request,
		.graph = graph,
		.mutex = mutex,
		.include = { .buildings = buildings, .roads = roads, .tagged_nodes = tagged_nodes, .cells = cells },
		.input_filenames = input_filenames,
		.mapped_files = mapped_files,
		.num_threads = num_threads,
		.report_frequency = report_frequency
	};

	pt_Memory tmp_way_memory      = { .handle = 0, .memblock = { .begin = 0, .end = 0 }};
	pt_Memory tmp_location_memory = { .handle = 0, .memblock = { .begin = 0, .end = 0 }};
	if (num_threads > 1) {

		/*
		 * allocate memory to have one TmpObject for each thread and
		 * for a queue of TmpObject
		 */
		s32 n = (s32) num_threads + ra_service_create_snap_OBJECT_QUEUE_SIZE;
		u64 tmp_way_memory_size = n * (sizeof(ra_TmpObject) +  /* record */
					       ra_service_create_snap_OBJECT_KEY_VALUE_BUFFER_SIZE + /* buffer for key values */
					       sizeof(u64) * ra_service_create_snap_MAX_NODES_PER_OBJECT /* buffer for node ids */
					       );

		// allocate lots of memory for tmp way buffer
		tmp_way_memory = platform.allocate_memory(tmp_way_memory_size, 3,0);

		ra_TmpObject *queue_tmpway_buffer  = (ra_TmpObject*) tmp_way_memory.memblock.begin;
		ra_TmpObject *thread_tmpway_buffer = queue_tmpway_buffer + ra_service_create_snap_OBJECT_QUEUE_SIZE;

		char *key_value_it = (char*) (thread_tmpway_buffer + num_threads);
		u64  *nodes_it     = (u64*) (key_value_it + n * ra_service_create_snap_OBJECT_KEY_VALUE_BUFFER_SIZE);

		for (s32 i=0; i<ra_service_create_snap_OBJECT_QUEUE_SIZE; ++i) {
			ra_TmpObject_init(queue_tmpway_buffer + i,
				       key_value_it, key_value_it + ra_service_create_snap_OBJECT_KEY_VALUE_BUFFER_SIZE,
				       nodes_it, nodes_it + ra_service_create_snap_MAX_NODES_PER_OBJECT);
			key_value_it += ra_service_create_snap_OBJECT_KEY_VALUE_BUFFER_SIZE;
			nodes_it     += ra_service_create_snap_MAX_NODES_PER_OBJECT;
		}

		for (s32 i=0; i<num_threads; ++i) {
			ra_TmpObject_init(thread_tmpway_buffer + i,
				       key_value_it, key_value_it + ra_service_create_snap_OBJECT_KEY_VALUE_BUFFER_SIZE,
				       nodes_it, nodes_it + ra_service_create_snap_MAX_NODES_PER_OBJECT);
			key_value_it += ra_service_create_snap_OBJECT_KEY_VALUE_BUFFER_SIZE;
			nodes_it     += ra_service_create_snap_MAX_NODES_PER_OBJECT;
		}

		// initialize multithread aspect of the ra_service_create_snap_info
		ra_service_create_snap_info.multithread.tmpway_queue = (ra_TmpObject_Queue) {
			.buffer = queue_tmpway_buffer,
			.length = ra_service_create_snap_OBJECT_QUEUE_SIZE,
			.left = 0,
			.right = 0
		};
		ra_service_create_snap_info.multithread.tmpway_threads = thread_tmpway_buffer;


		/*
		 * location queue memory
		 */
		tmp_location_memory = platform.allocate_memory(sizeof(ra_Location) * ra_service_create_snap_LOCATION_QUEUE_SIZE, 3, 0);
		ra_service_create_snap_info.multithread.location_queue = (ra_Location_Queue) {
			.buffer = (ra_Location*) tmp_location_memory.memblock.begin,
			.length = ra_service_create_snap_LOCATION_QUEUE_SIZE,
			.left = 0,
			.right = 0
		};
		for (s32 i=0;i<ra_service_create_snap_LOCATION_QUEUE_SIZE;++i) {
			ra_service_create_snap_info.multithread.location_queue.buffer[i] = (ra_Location) { .id = 0, .ready=0, .lat=0.0f, .lon=0.0f };
		}

		ra_service_create_snap_info.multithread.jobs_completed = 0;

	} else {
		ra_service_create_snap_info.multithread.tmpway_queue = (ra_TmpObject_Queue) {
			.buffer = 0, .length = 0, .left = 0, .right = 0
		};
		ra_service_create_snap_info.multithread.tmpway_threads = 0;
		ra_service_create_snap_info.multithread.location_queue = (ra_Location_Queue) {
			.buffer = 0, .length=0, .left = 0, .right = 0
		};
		ra_service_create_snap_info.multithread.jobs_completed = 0;
	}


	pt_WorkQueue *work_queue = 0;
	if (num_threads > 1) {
		// one of the threads is the main thread
		work_queue = platform.work_queue_create(num_threads-1);
		// log message to differentiate from sequential server
		print_clear(print);
		print_format(print, "[ra_service_create_snap] using %llu threads\n", num_threads);
		output_( print);
	}

	// Stage 1: find all ways in all files
	if (work_queue) {

		ra_service_create_snap_info.multithread.jobs_completed = 0;

		pt_memory_barrier();

		for (s32 i=0;i<num_input_files;++i) {
			platform.work_queue_add_entry(work_queue, ra_service_create_snap_parse_ways_callback, input_indices + i);
		}

		/* keep consuming data while the work_queue hasn't finish its jobs */
		ra_TmpObject_Queue *queue = &ra_service_create_snap_info.multithread.tmpway_queue;
		for (;;) {
			for (;;) {
				ra_TmpObject *head = ra_TmpObject_Queue_head(queue);
				if (head) {
					// insert way into graph (no mutex necessary)
					Assert(head->ready);

					ra_service_create_snap_insert_way(head);

					ra_TmpObject_Queue_pop_head(queue);
				} else {
					break;
				}
			}
			// this has to access two volatile variables not very efficient
			// to be competing to queue processing in our profile run it
			// was accounting for 26% of the time
			if (ra_service_create_snap_info.multithread.jobs_completed == num_input_files) {
				// there might still be residual data in the queue
				break;
			}
		}
		{
			// make sure no residual is left on the queue
			ra_TmpObject *head = 0;
			while ((head = ra_TmpObject_Queue_head(queue))) {
				// insert way into graph (no mutex necessary)
				Assert(head->ready);
				ra_service_create_snap_insert_way(head);

				ra_TmpObject_Queue_pop_head(queue);
			}
		}
	} else {
		for (s32 i=0;i<num_input_files;++i) {
			ra_service_create_snap_parse_ways_single_threaded(i);
		}
	}

	{
		print_clear(print);
		print_cstr(print, "Initializing incidence of nodes...");
		print_align(print, 80, -1, '.');
		output_( print);

		f64 t0 = platform.get_time();

		/* initialize nodes incidence */
		rg_Graph_initialize_locates_incidence(graph);

		print_clear(print);
		print_u64(print, (u64) (platform.get_time() - t0));
		print_align(print, 14, 1, '.');
		print_cstr(print, " secs\n");
		output_( print);
	}

	f32 t0 = platform.get_time();
	print_clear(print);
	print_cstr(print, "Second pass over the data (capture nodes lat/lon)...\n");
// 	print_align(print, 80, -1, '.');
	output_( print);

// 	for (s32 i=0;i<num_input_files;++i) {
// 		ra_service_create_snap_parse_nodes(request, graph, i, mapped_files + i);
// 	}

	// Stage 2: find all ways in all files
	if (work_queue) {

		ra_service_create_snap_info.multithread.jobs_completed = 0;

		pt_memory_barrier();

		for (s32 i=0;i<num_input_files;++i) {
			platform.work_queue_add_entry(work_queue, ra_service_create_snap_parse_nodes_callback, input_indices + i);
		}
		/* keep consuming data while the work_queue hasn't finish its jobs */
		ra_Location_Queue *queue = &ra_service_create_snap_info.multithread.location_queue;
		for (;;) {
			for (;;) {
				ra_Location *head = ra_Location_Queue_head(queue);
				if (head) {
					// insert way into graph (no mutex necessary)
					Assert(head->ready);
					ra_service_create_snap_update_location(head);
					ra_Location_Queue_pop_head(queue);
				} else {
					break;
				}
			}
			if (ra_service_create_snap_info.multithread.jobs_completed == num_input_files) {
				// there might still be residual data in the queue
				break;
			}
		}
		{
			// make sure no residual is left on the queue
			ra_Location *head = 0;
			while ((head = ra_Location_Queue_head(queue))) {
				// insert way into graph (no mutex necessary)
				Assert(head->ready);
				ra_service_create_snap_update_location(head);
				ra_Location_Queue_pop_head(queue);
			}
		}
	} else {
		for (s32 i=0;i<num_input_files;++i) {
			ra_service_create_snap_parse_nodes_single_threaded(i);
		}
	}

// 	if (work_queue) {
// 		platform.work_queue_destroy(work_queue);
// 	}

	/* vptree */
	t0 = platform.get_time();

	print_clear(print);
	print_cstr(print, "Creating Vantage Point Tree...");
	output_( print);

	pt_Memory vp_buffer = platform.allocate_memory(graph->nodes.size * sizeof(rg_VPNode), 3, 0);
	rg_Graph_initalize_vantage_point_tree(graph, vp_buffer.memblock.begin, vp_buffer.memblock.end);
	platform.free_memory(&vp_buffer);

	t0 = platform.get_time() - t0;

	print_clear(print);
	print_format(print, "%.2fs\n",t0);
	output_( print);

	/* save graph on file */
	t0 = platform.get_time();

	pt_File pfh_db = platform.open_write_file(output_filename.begin, output_filename.end);
	platform.write_to_file (&pfh_db, (char*) allocator, (char*) allocator + al_Allocator_used_memory(allocator));
	platform.close_file(&pfh_db);


	print_clear(print);
	print_cstr(print, "file:");
	print_str(print, output_filename.begin, output_filename.end);
	print_cstr(print, "     time:");
	print_u64(print, (u64) (platform.get_time() - t0));
	print_cstr(print, "s    size:");
	print_u64(print, (u64) al_Allocator_used_memory(allocator));
	print_cstr(print, "\n");
	output_( print);

	platform.free_memory(&tmp_way_memory);
	platform.free_memory(&tmp_location_memory);

	/* close all memory mapped files */
	for (s32 i=0;i<num_input_files;++i) {
		platform.close_mmap_file(mapped_files + i);
	}

#endif

}

static void
ra_service_btree(Request *request)
{
	// @todo @uncomment
#if 0
	Print *print = request->print;

	pt_Memory data_memory = platform.allocate_memory(Gigabytes(2), 12, Terabytes(2));

	al_Allocator *allocator   = al_Allocator_new(data_memory.memblock.begin, data_memory.memblock.end);
	al_Cache     *btree_cache = al_Allocator_create_cache(allocator, "rbt_BTree", sizeof(rbt_BTree));
	rbt_BTree     *btree       = (rbt_BTree*) al_Cache_alloc(btree_cache);

	rbt_BTree_init(btree, allocator);

	for (u32 i=0;i<10000;++i) {
		u64  key    = (u64) rnd_next();
		char *value = (char *) key;
		rbt_BTree_insert(btree, key, value);
	}

	rbt_Iter iter;
	rbt_Iter_init(&iter, btree);

	u64  key    = 0;
	char *value = 0;
	u64  i = 0;
	while (rbt_Iter_next(&iter,&key, &value)) {
		++i;
		print_clear(print);
		print_cstr(print, "[");
		print_u64(print, i);
		print_align(print, 9, 1, ' ');
		print_cstr(print, "] ");
		print_u64(print, key);
		print_align(print, 20, 1, ' ');
		print_cstr(print, " -> ");
		print_u64(print, *((u64*) &value));
		print_align(print, 20, 1, ' ');
		print_cstr(print, "\n");
		output_( print);
	}
	platform.free_memory(&data_memory);
#endif
}

static void
ra_service_closest(Request *request)
{
	// @todo @uncomment
#if 0
	Print      *print   = request->print;
	op_Options *options = &request->options;

	MemoryBlock input_filename  = { .begin=0, .end=0 };
	u64 k = 0;
	f32 lat = 0.0f;
	f32 lon = 0.0f;

	if (!op_Options_str(options, 1, &input_filename)
	    || !op_Options_u64(options, 2, &k)
	    || !op_Options_f32(options, 3, &lat)
	    || !op_Options_f32(options, 4, &lon)) {
		log_cstr_("[ra_closest] invalid arguments\n");
		log_cstr_("[ra_closese] usage: closest <roadmap-filename> <k> <lat> <lon>>\n");
		return;
	}

	//
	// could do it in the memory map way
	// add to the platform a way to map a file
	//
	pt_MappedFile mapped_file = platform.open_mmap_file(input_filename.begin, input_filename.end, 1, 0);
	if (!mapped_file.mapped) {
		log_cstr_("[closest] couldn't open of the <xml> file.\n");
		return;
	}

	al_Allocator* allocator = (al_Allocator*) mapped_file.begin;
	rg_Graph *graph = (rg_Graph*) al_Ptr_char_get(&allocator->root_p);


	pt_Memory heap_memory = platform.allocate_memory(k * sizeof(rg_HeapItem), 12, 0);
	rg_HeapItem *heap_begin = (rg_HeapItem*) heap_memory.memblock.begin;
	rg_HeapItem *heap_end   = heap_begin + k;
	rg_Heap heap;
	rg_Heap_init(&heap, heap_begin, heap_end);

	f64 t0 = platform.get_time();

	rbt_Iter iter;
	rbt_Iter_init(&iter, &graph->nodes);
	u64  key    = 0;
	char *value = 0;
// 	u64 count = 0;
	while (rbt_Iter_next(&iter, &key, &value)) {
// 		++count;

		rg_Locate *node = (rg_Locate*) value;

		f64 distance = rg_vp_dist(node, lat, lon);

		if (rg_Heap_full(&heap)) {
			if (distance < -rg_Heap_min(&heap)) {
				rg_Heap_pop(&heap);
				rg_Heap_insert(&heap, node, -distance);
			}
		} else {
			rg_Heap_insert(&heap, node, -distance);
		}

// 		if (count == k + 3)
// 			break;
	}

	t0 = platform.get_time() - t0;

	rg_Heap_final_sort(&heap);
	rg_HeapItem *it  = heap.begin;
	rg_HeapItem *end = heap.end;
	u64 index = 0;
	while (it != end) {
		++index;
		rg_Locate *node = (rg_Locate*) it->data;
		print_clear(print);
		print_cstr(print,"[");
		print_u64(print,index);
		print_align(print,8,1,' ');
		print_cstr(print,"]  ");
		print_u64(print,node->id);
		print_align(print,16,1,' ');
		print_f64(print,-it->value);
		print_align(print,16,1,' ');
		print_cstr(print,"\n");
		output_( print);

		if (node->num_objects == 1) {
			rg_Object *object = rg_Ptr_Object_get(&node->singleton);
			print_clear(print);
			print_cstr(print,"  ");
			ra_print_object(print, object);
			output_( print);
			ra_print_object(print, object);
		} else if (node->num_objects > 1) {
			rg_Ptr_Object *objects_begin = (rg_Ptr_Object*) al_Ptr_char_get(&node->objects);
			rg_Ptr_Object *objects_end   = objects_begin + node->num_objects;
			rg_Ptr_Object *it_object = objects_begin;
			while (it_object != objects_end) {
				rg_Object *object = rg_Ptr_Object_get(it_object);
				print_clear(print);
				print_cstr(print,"  ");
				ra_print_object(print, object);
				output_( print);
				++it_object;
			}
		}

		print_clear(print);
		print_cstr(print,"\n");
		output_( print);

		++it;
	}

	print_clear(print);
	print_cstr(print,"Time to find closest points: ");
	print_f64(print, (f64) t0);
	print_cstr(print, "s\n");
	output_( print);

	platform.free_memory(&heap_memory);
	platform.close_mmap_file(&mapped_file);

#endif

}

static void
ra_print_vpitems(Print *print, rg_VPNode *begin, rg_VPNode *end, rg_VPNode *highlight)
{
	rg_VPNode *it = begin;
	while (it != end) {
		if (it == highlight) {
			print_cstr(print, "[*");
			print_s64(print, it - begin);
			print_align(print, 4, 1, ' ');
		} else {
			print_cstr(print, "[");
			print_s64(print, it - begin);
			print_align(print, 5, 1, ' ');
		}
		print_cstr(print, "] -> ");
		print_u64(print, (u64) it->distance);
		print_align(print, 5, 1, ' ');
		print_cstr(print, "\n");
		++it;
	}
}


static void
ra_service_ksmall(Request *request)
{
	Print      *print   = request->print;
	op_Options *options = &request->options;

	u64 k = 0;
	if (!op_Options_u64(options, 1, &k)) {
		log_cstr_("[ra_ksmall] no filename provided\n");
		log_cstr_("[ra_ksmall] 6 9 6 5 6 2 4\n");
		return;
	}

	/*
	rg_VPNode array[7];
	array[0].distance = 6.0f;
	array[1].distance = 9.0f;
	array[2].distance = 6.0f;
	array[3].distance = 5.0f;
	array[4].distance = 6.0f;
	array[5].distance = 2.0f;
	array[6].distance = 4.0f;
	rg_VPNode *begin = array;
	rg_VPNode *end   = array + 7;
	*/
	const u32 N = 30;
	rnd_state = 123897;
	rg_VPNode array[N];
	s64 repeat = 3;
	for (u32 i=0;i<N;i+=repeat) {
		rnd_next();
		for (u32 j=0;j<repeat;++j)
			array[i+j].distance = rnd_state;
	}
	rg_VPNode *begin = array;
	rg_VPNode *end   = array + N;

	print_clear(print);
	print_cstr(print, "Before: \n");
	ra_print_vpitems(print, begin, end, 0);
	output_( print);

	rg_VPNode *result = rg_vp_kth_smallest(begin, end, k);

	print_clear(print);
	print_cstr(print, "After: \n");
	ra_print_vpitems(print, begin, end, result);
	output_( print);
}

//
// Use the expression language already available in nanocube/nanocube_parser.c
// to parse HTTP requests.
//

typedef struct
{
	np_TypeID number;
	np_TypeID string;
	np_TypeID config;
	np_TypeID locates;
	np_TypeID radius;
	np_TypeID format;
	np_TypeID filter_exp;
	np_TypeID filter;
	np_TypeID order;
	np_TypeID help;
	np_TypeID k;
	np_TypeID support;
} ra_roadsnap_CompilerTypes;

global_variable ra_roadsnap_CompilerTypes ra_roadsnap_compiler_types;

#define ra_roadsnap_FORMAT_JSON 1
#define ra_roadsnap_FORMAT_TEXT 2
#define ra_roadsnap_FORMAT_XML  3
#define ra_roadsnap_FORMAT_HTML 4
#define ra_roadsnap_FORMAT_LEAFLET 5

#define ra_roadsnap_ORDER_LOCATES_OBJECTS      0
#define ra_roadsnap_ORDER_OBJECTS_LOCATES      1
#define ra_roadsnap_ORDER_OBJECTS_ALL_LOCATES  2

typedef struct {
	f32 lat;
	f32 lon;
} ra_roadsnap_LatLon;

typedef struct {
	s32 num_locates;
	ra_roadsnap_LatLon *locates;
} ra_roadsnap_Locates;

typedef struct {
	f32 radius;
} ra_roadsnap_Radius;

typedef struct {
	u8 format;
} ra_roadsnap_Format;

typedef struct {
	s32 k;
} ra_roadsnap_K;

typedef struct {
	u8 order;
} ra_roadsnap_Order;

typedef struct {
	u8 dummy;
} ra_roadsnap_Help;

typedef struct {
	s32 min;
	s32 max;
} ra_roadsnap_Support;

#define ra_roadsnap_FILTER_NULL       0
#define ra_roadsnap_FILTER_AND        1
#define ra_roadsnap_FILTER_OR         2
#define ra_roadsnap_FILTER_NOT        3
#define ra_roadsnap_FILTER_KEY        4
#define ra_roadsnap_FILTER_VALUE      5
#define ra_roadsnap_FILTER_KEY_VALUE  6
typedef struct ra_roadsnap_FilterExp {
	u8 type;
	MemoryBlock key;
	MemoryBlock value;
	struct ra_roadsnap_FilterExp *left;
	struct ra_roadsnap_FilterExp *right;
} ra_roadsnap_FilterExp;

typedef struct {
	s32                   k;
	f32                   radius;
	u8                    format;
	ra_roadsnap_Locates   locates;
	ra_roadsnap_FilterExp *filter;
	s32                   order;
	// if min and max are negative it means -infinity for min and +infinity for max
	struct {
		s32 min;
		s32 max;
	} support;
} ra_roadsnap_Config;

np_FUNCTION_HANDLER(ra_roadsnap_function_support)
{
	Assert(params_begin + 2 == params_end);
	np_TypeValue *min_tv = params_begin;
	np_TypeValue *max_tv = params_begin + 1;
	Assert(min_tv->type_id == ra_roadsnap_compiler_types.number);
	Assert(max_tv->type_id == ra_roadsnap_compiler_types.number);

	ra_roadsnap_Support *result = (ra_roadsnap_Support*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_Support));
	result->min = (s32) (*(f64*) min_tv->value);
	result->max = (s32) (*(f64*) max_tv->value);

	return np_TypeValue_value(ra_roadsnap_compiler_types.support, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_order)
{
	Assert(params_begin + 1 == params_end);
	np_TypeValue *order_name_tv = params_begin;
	Assert(order_name_tv->type_id == ra_roadsnap_compiler_types.string);
	MemoryBlock order_name = *((MemoryBlock*) order_name_tv->value);
	ra_roadsnap_Order *result = (ra_roadsnap_Order*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_Order));
	// log error message if order name is not json or text
	if (cstr_compare_memory_cstr(order_name.begin, order_name.end, "locates") == 0) {
		result->order = ra_roadsnap_ORDER_LOCATES_OBJECTS;
	} else if (cstr_compare_memory_cstr(order_name.begin, order_name.end, "objects") == 0) {
		result->order = ra_roadsnap_ORDER_OBJECTS_LOCATES;
	} else if (cstr_compare_memory_cstr(order_name.begin, order_name.end, "objects_all") == 0) {
		result->order = ra_roadsnap_ORDER_OBJECTS_ALL_LOCATES;
	} else {
		char *error = "Invalid roadsnap order (it needs to be either 'locates', 'objects', 'objects_all')\n";
		np_Compiler_log_custom_error(compiler, error, cstr_end(error));
		np_Compiler_log_ast_node_context(compiler);
		return np_TypeValue_error();
	}
	return np_TypeValue_value(ra_roadsnap_compiler_types.order, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_filter_kv)
{
	Assert(params_begin + 2 == params_end);
	np_TypeValue *key_tv   = params_begin;
	np_TypeValue *value_tv = params_begin+1;
	Assert(key_tv->type_id == ra_roadsnap_compiler_types.string);
	Assert(value_tv->type_id == ra_roadsnap_compiler_types.string);

	MemoryBlock key   = *((MemoryBlock*) key_tv->value);
	MemoryBlock value = *((MemoryBlock*) value_tv->value);

	/* NOTE(llins) we don't care about collisions for now */
	ra_roadsnap_FilterExp *result = (ra_roadsnap_FilterExp*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_FilterExp));
	*result = (ra_roadsnap_FilterExp) { .type = ra_roadsnap_FILTER_KEY_VALUE, .key = key, .value = value };

	return np_TypeValue_value(ra_roadsnap_compiler_types.filter_exp, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_filter_k)
{
	Assert(params_begin + 1 == params_end);
	np_TypeValue *key_tv   = params_begin;
	Assert(key_tv->type_id == ra_roadsnap_compiler_types.string);

	MemoryBlock key   = *((MemoryBlock*) key_tv->value);

	/* NOTE(llins) we don't care about collisions for now */
	ra_roadsnap_FilterExp *result = (ra_roadsnap_FilterExp*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_FilterExp));
	*result = (ra_roadsnap_FilterExp) { .type = ra_roadsnap_FILTER_KEY, .key = key };

	return np_TypeValue_value(ra_roadsnap_compiler_types.filter_exp, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_filter_v)
{
	Assert(params_begin + 1 == params_end);
	np_TypeValue *value_tv   = params_begin;
	Assert(value_tv->type_id == ra_roadsnap_compiler_types.string);

	MemoryBlock value   = *((MemoryBlock*) value_tv->value);

	/* NOTE(llins) we don't care about collisions for now */
	ra_roadsnap_FilterExp *result = (ra_roadsnap_FilterExp*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_FilterExp));
	*result = (ra_roadsnap_FilterExp) { .type = ra_roadsnap_FILTER_VALUE, .value = value };

	return np_TypeValue_value(ra_roadsnap_compiler_types.filter_exp, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_filter_and)
{
	Assert(params_begin + 2 == params_end);
	np_TypeValue *left_tv  = params_begin;
	np_TypeValue *right_tv = params_begin+1;
	Assert(left_tv->type_id  == ra_roadsnap_compiler_types.filter_exp);
	Assert(right_tv->type_id == ra_roadsnap_compiler_types.filter_exp);

	ra_roadsnap_FilterExp *left  = (ra_roadsnap_FilterExp*) left_tv->value;
	ra_roadsnap_FilterExp *right = (ra_roadsnap_FilterExp*) right_tv->value;

	/* NOTE(llins) we don't care about collisions for now */
	ra_roadsnap_FilterExp *result = (ra_roadsnap_FilterExp*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_FilterExp));
	*result = (ra_roadsnap_FilterExp) { .type = ra_roadsnap_FILTER_AND, .left = left, .right = right };

	return np_TypeValue_value(ra_roadsnap_compiler_types.filter_exp, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_filter_or)
{
	Assert(params_begin + 2 == params_end);
	np_TypeValue *left_tv  = params_begin;
	np_TypeValue *right_tv = params_begin+1;
	Assert(left_tv->type_id  == ra_roadsnap_compiler_types.filter_exp);
	Assert(right_tv->type_id == ra_roadsnap_compiler_types.filter_exp);

	ra_roadsnap_FilterExp *left  = (ra_roadsnap_FilterExp*) left_tv->value;
	ra_roadsnap_FilterExp *right = (ra_roadsnap_FilterExp*) right_tv->value;

	/* NOTE(llins) we don't care about collisions for now */
	ra_roadsnap_FilterExp *result = (ra_roadsnap_FilterExp*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_FilterExp));
	*result = (ra_roadsnap_FilterExp) { .type = ra_roadsnap_FILTER_OR, .left = left, .right = right };

	return np_TypeValue_value(ra_roadsnap_compiler_types.filter_exp, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_filter_not)
{
	Assert(params_begin + 1 == params_end);
	np_TypeValue *left_tv  = params_begin;
	Assert(left_tv->type_id  == ra_roadsnap_compiler_types.filter_exp);

	ra_roadsnap_FilterExp *left  = (ra_roadsnap_FilterExp*) left_tv->value;

	/* NOTE(llins) we don't care about collisions for now */
	ra_roadsnap_FilterExp *result = (ra_roadsnap_FilterExp*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_FilterExp));
	*result = (ra_roadsnap_FilterExp) { .type = ra_roadsnap_FILTER_NOT, .left = left, .right = 0 };

	return np_TypeValue_value(ra_roadsnap_compiler_types.filter_exp, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_filter)
{
	Assert(params_begin + 1 == params_end);
	np_TypeValue *expression_tv  = params_begin;
	Assert(expression_tv->type_id  == ra_roadsnap_compiler_types.filter_exp);

	ra_roadsnap_FilterExp *expression  = (ra_roadsnap_FilterExp*) expression_tv->value;

	return np_TypeValue_value(ra_roadsnap_compiler_types.filter, expression);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_format)
{
	Assert(params_begin + 1 == params_end);
	np_TypeValue *format_name_tv = params_begin;
	Assert(format_name_tv->type_id == ra_roadsnap_compiler_types.string);
	MemoryBlock format_name = *((MemoryBlock*) format_name_tv->value);
	ra_roadsnap_Format *result = (ra_roadsnap_Format*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_Format));
	// log error message if format name is not json or text
	if (cstr_compare_memory_cstr(format_name.begin, format_name.end, "json") == 0) {
		result->format = ra_roadsnap_FORMAT_JSON;
	} else if (cstr_compare_memory_cstr(format_name.begin, format_name.end, "text") == 0) {
		result->format = ra_roadsnap_FORMAT_TEXT;
	} else if (cstr_compare_memory_cstr(format_name.begin, format_name.end, "xml") == 0) {
		result->format = ra_roadsnap_FORMAT_XML;
	} else if (cstr_compare_memory_cstr(format_name.begin, format_name.end, "html") == 0) {
		result->format = ra_roadsnap_FORMAT_HTML;
	} else if (cstr_compare_memory_cstr(format_name.begin, format_name.end, "leaflet") == 0) {
		result->format = ra_roadsnap_FORMAT_LEAFLET;
	} else {
		char *error = "Invalid roadsnap format (it needs to be either 'text', 'json', 'xml', 'html' or 'leaflet')\n";
		np_Compiler_log_custom_error(compiler, error, cstr_end(error));
		np_Compiler_log_ast_node_context(compiler);
		return np_TypeValue_error();
	}
	return np_TypeValue_value(ra_roadsnap_compiler_types.format, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_radius)
{
	Assert(params_begin + 1 == params_end);
	np_TypeValue *radius_tv = params_begin;
	Assert(radius_tv->type_id == ra_roadsnap_compiler_types.number);
	ra_roadsnap_Radius *result = (ra_roadsnap_Radius*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_Radius));
	result->radius = (f32) (*(f64*) radius_tv->value);
	if (result->radius < 0) {
		char *error = "Invalid 'r' value. Radius need to be non-negative.\n";
		np_Compiler_log_custom_error(compiler, error, cstr_end(error));
		np_Compiler_log_ast_node_context(compiler);
		return np_TypeValue_error();
	}
	return np_TypeValue_value(ra_roadsnap_compiler_types.radius, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_max_locates)
{
	Assert(params_begin + 1 == params_end);
	np_TypeValue *k_tv = params_begin;
	Assert(k_tv->type_id == ra_roadsnap_compiler_types.number);
	ra_roadsnap_K *result = (ra_roadsnap_K*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_K));
	result->k = (s32) (*(f64*) k_tv->value);
	if (result->k <= 0) {
		char *error = "Invalid 'k' value. needs to be greater than zero.\n";
		np_Compiler_log_custom_error(compiler, error, cstr_end(error));
		np_Compiler_log_ast_node_context(compiler);
		return np_TypeValue_error();
	}
	return np_TypeValue_value(ra_roadsnap_compiler_types.k, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_locates)
{
	s64 n = params_end - params_begin;
	if ((n <= 0) || (n % 2 != 0)) {
		char *error = "'loc' function expects pairs of lat/lon eg. loc(40.5,-78.3,43.5,-76.5)\n";
		np_Compiler_log_custom_error(compiler, error, cstr_end(error));
		np_Compiler_log_ast_node_context(compiler);
		return np_TypeValue_error();
	}
	ra_roadsnap_Locates *result  = (ra_roadsnap_Locates*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_Locates));
	result->num_locates = n/2;
	result->locates = (ra_roadsnap_LatLon*) np_Compiler_alloc(compiler, result->num_locates * sizeof(ra_roadsnap_LatLon));

	np_TypeValue *it = params_begin;
	for (s64 i=0;i<n;i+=2) {
		f32 lat = (f32) (*(f64*) it->value);
		f32 lon = (f32) (*(f64*) (it+1)->value);
		it+=2;
		result->locates[i/2] = (ra_roadsnap_LatLon) { .lat=lat, .lon=lon };
	}
	return np_TypeValue_value(ra_roadsnap_compiler_types.locates, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_config_radius)
{
	Assert(params_begin + 2 == params_end);
	np_TypeValue *config_tv = params_begin;
	np_TypeValue *radius_tv = params_begin + 1;
	Assert(config_tv->type_id == ra_roadsnap_compiler_types.config);
	Assert(radius_tv->type_id == ra_roadsnap_compiler_types.radius);
	ra_roadsnap_Config *result = (ra_roadsnap_Config*) config_tv->value;
	if (config_tv->readonly) {
		result  = (ra_roadsnap_Config*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_Config));
		*result = *((ra_roadsnap_Config*) config_tv->value);
	}
	result->radius = ((ra_roadsnap_Radius*) radius_tv->value)->radius;
	return np_TypeValue_value(ra_roadsnap_compiler_types.config, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_config_locates)
{
	Assert(params_begin + 2 == params_end);
	np_TypeValue *config_tv  = params_begin;
	np_TypeValue *locates_tv = params_begin + 1;
	Assert(config_tv->type_id  == ra_roadsnap_compiler_types.config);
	Assert(locates_tv->type_id == ra_roadsnap_compiler_types.locates);
	ra_roadsnap_Config *result = (ra_roadsnap_Config*) config_tv->value;
	if (config_tv->readonly) {
		result  = (ra_roadsnap_Config*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_Config));
		*result = *((ra_roadsnap_Config*) config_tv->value);
	}
	result->locates = *((ra_roadsnap_Locates*)locates_tv->value);
	return np_TypeValue_value(ra_roadsnap_compiler_types.config, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_config_format)
{
	Assert(params_begin + 2 == params_end);
	np_TypeValue *config_tv = params_begin;
	np_TypeValue *format_tv = params_begin + 1;
	Assert(config_tv->type_id == ra_roadsnap_compiler_types.config);
	Assert(format_tv->type_id == ra_roadsnap_compiler_types.format);
	ra_roadsnap_Config *result = (ra_roadsnap_Config*) config_tv->value;
	if (config_tv->readonly) {
		result  = (ra_roadsnap_Config*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_Config));
		*result = *((ra_roadsnap_Config*) config_tv->value);
	}
	result->format = ((ra_roadsnap_Format*)format_tv->value)->format;
	return np_TypeValue_value(ra_roadsnap_compiler_types.config, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_config_order)
{
	Assert(params_begin + 2 == params_end);
	np_TypeValue *config_tv = params_begin;
	np_TypeValue *order_tv = params_begin + 1;
	Assert(config_tv->type_id == ra_roadsnap_compiler_types.config);
	Assert(order_tv->type_id == ra_roadsnap_compiler_types.order);
	ra_roadsnap_Config *result = (ra_roadsnap_Config*) config_tv->value;
	if (config_tv->readonly) {
		result  = (ra_roadsnap_Config*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_Config));
		*result = *((ra_roadsnap_Config*) config_tv->value);
	}
	result->order = ((ra_roadsnap_Order*)order_tv->value)->order;
	return np_TypeValue_value(ra_roadsnap_compiler_types.config, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_config_k)
{
	Assert(params_begin + 2 == params_end);
	np_TypeValue *config_tv = params_begin;
	np_TypeValue *k_tv      = params_begin + 1;
	Assert(config_tv->type_id == ra_roadsnap_compiler_types.config);
	Assert(k_tv->type_id      == ra_roadsnap_compiler_types.k);
	ra_roadsnap_Config *result = (ra_roadsnap_Config*) config_tv->value;
	if (config_tv->readonly) {
		result  = (ra_roadsnap_Config*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_Config));
		*result = *((ra_roadsnap_Config*) config_tv->value);
	}
	result->k = ((ra_roadsnap_K*)k_tv->value)->k;
	return np_TypeValue_value(ra_roadsnap_compiler_types.config, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_config_filter)
{
	Assert(params_begin + 2 == params_end);
	np_TypeValue *config_tv = params_begin;
	np_TypeValue *filter_tv = params_begin + 1;
	Assert(config_tv->type_id == ra_roadsnap_compiler_types.config);
	Assert(filter_tv->type_id == ra_roadsnap_compiler_types.filter);
	ra_roadsnap_Config *result = (ra_roadsnap_Config*) config_tv->value;
	if (config_tv->readonly) {
		result  = (ra_roadsnap_Config*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_Config));
		*result = *((ra_roadsnap_Config*) config_tv->value);
	}
	result->filter = ((ra_roadsnap_FilterExp*) filter_tv->value);
	return np_TypeValue_value(ra_roadsnap_compiler_types.config, result);
}

np_FUNCTION_HANDLER(ra_roadsnap_function_config_support)
{
	Assert(params_begin + 2 == params_end);
	np_TypeValue *config_tv = params_begin;
	np_TypeValue *support_tv = params_begin + 1;
	Assert(config_tv->type_id == ra_roadsnap_compiler_types.config);
	Assert(support_tv->type_id == ra_roadsnap_compiler_types.support);
	ra_roadsnap_Config *result = (ra_roadsnap_Config*) config_tv->value;
	if (config_tv->readonly) {
		result  = (ra_roadsnap_Config*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_Config));
		*result = *((ra_roadsnap_Config*) config_tv->value);
	}
	result->support.min = ((ra_roadsnap_Support*) support_tv->value)->min;
	result->support.max = ((ra_roadsnap_Support*) support_tv->value)->max;
	return np_TypeValue_value(ra_roadsnap_compiler_types.config, result);
}

static void
ra_roadsnap_init_query_compiler(np_Compiler* compiler)
{
	/* register types */
	ra_roadsnap_compiler_types.number     = compiler->number_type_id;
	ra_roadsnap_compiler_types.string     = compiler->string_type_id;
	ra_roadsnap_compiler_types.config     = np_Compiler_insert_type_cstr(compiler, "ra_roadsnap_Config")->id;
	ra_roadsnap_compiler_types.locates    = np_Compiler_insert_type_cstr(compiler, "ra_roadsnap_Locates")->id;
	ra_roadsnap_compiler_types.radius     = np_Compiler_insert_type_cstr(compiler, "ra_roadsnap_Radius")->id;
	ra_roadsnap_compiler_types.format     = np_Compiler_insert_type_cstr(compiler, "ra_roadsnap_Format")->id;
	ra_roadsnap_compiler_types.k          = np_Compiler_insert_type_cstr(compiler, "ra_roadsnap_K")->id;
	ra_roadsnap_compiler_types.filter     = np_Compiler_insert_type_cstr(compiler, "ra_roadsnap_Filter")->id;
	ra_roadsnap_compiler_types.filter_exp = np_Compiler_insert_type_cstr(compiler, "ra_roadsnap_FilterExp")->id;
	ra_roadsnap_compiler_types.order      = np_Compiler_insert_type_cstr(compiler, "ra_roadsnap_Order")->id;
	ra_roadsnap_compiler_types.help       = np_Compiler_insert_type_cstr(compiler, "ra_roadsnap_Help")->id;
	ra_roadsnap_compiler_types.support    = np_Compiler_insert_type_cstr(compiler, "ra_roadsnap_Support")->id;

	/* */
	// and operators
	np_TypeID parameter_types[2];

	// p: format("json" or "text")
	parameter_types[0] = ra_roadsnap_compiler_types.string;
	np_Compiler_insert_function_cstr(compiler, "format",
					 ra_roadsnap_compiler_types.format,
					 parameter_types, parameter_types+1,
					 0, 0,
					 ra_roadsnap_function_format);

	parameter_types[0] = ra_roadsnap_compiler_types.string;
	np_Compiler_insert_function_cstr(compiler, "order",
					 ra_roadsnap_compiler_types.order,
					 parameter_types, parameter_types+1,
					 0, 0,
					 ra_roadsnap_function_order);

	parameter_types[0] = ra_roadsnap_compiler_types.number;
	np_Compiler_insert_function_cstr(compiler, "max",
					 ra_roadsnap_compiler_types.k,
					 parameter_types, parameter_types+1,
					 0, 0,
					 ra_roadsnap_function_max_locates);

	parameter_types[0] = ra_roadsnap_compiler_types.number;
	np_Compiler_insert_function_cstr(compiler, "radius",
					 ra_roadsnap_compiler_types.radius,
					 parameter_types, parameter_types+1,
					 0, 0,
					 ra_roadsnap_function_radius);

	np_Compiler_insert_function_cstr(compiler, "loc",
					 ra_roadsnap_compiler_types.locates,
					 0, 0,
					 1, ra_roadsnap_compiler_types.number,
					 ra_roadsnap_function_locates);

	parameter_types[0] = ra_roadsnap_compiler_types.string;
	np_Compiler_insert_function_cstr(compiler, "k",
					 ra_roadsnap_compiler_types.filter_exp,
					 parameter_types, parameter_types+1,
					 0, 0,
					 ra_roadsnap_function_filter_k);

	parameter_types[0] = ra_roadsnap_compiler_types.string;
	np_Compiler_insert_function_cstr(compiler, "v",
					 ra_roadsnap_compiler_types.filter_exp,
					 parameter_types, parameter_types+1,
					 0, 0,
					 ra_roadsnap_function_filter_v);

	parameter_types[0] = ra_roadsnap_compiler_types.string;
	parameter_types[1] = ra_roadsnap_compiler_types.string;
	np_Compiler_insert_function_cstr(compiler, "kv",
					 ra_roadsnap_compiler_types.filter,
					 parameter_types, parameter_types+2,
					 0, 0,
					 ra_roadsnap_function_filter_kv);

	parameter_types[0] = ra_roadsnap_compiler_types.filter_exp;
	np_Compiler_insert_function_cstr(compiler, "not",
					 ra_roadsnap_compiler_types.filter_exp,
					 parameter_types, parameter_types+1,
					 0, 0,
					 ra_roadsnap_function_filter_not);

	parameter_types[0] = ra_roadsnap_compiler_types.filter_exp;
	parameter_types[1] = ra_roadsnap_compiler_types.filter_exp;
	np_Compiler_insert_function_cstr(compiler, "*",
					 ra_roadsnap_compiler_types.filter_exp,
					 parameter_types, parameter_types+2,
					 0, 0,
					 ra_roadsnap_function_filter_and);

	parameter_types[0] = ra_roadsnap_compiler_types.filter_exp;
	parameter_types[1] = ra_roadsnap_compiler_types.filter_exp;
	np_Compiler_insert_function_cstr(compiler, "+",
					 ra_roadsnap_compiler_types.filter_exp,
					 parameter_types, parameter_types+2,
					 0, 0,
					 ra_roadsnap_function_filter_or);

	parameter_types[0] = ra_roadsnap_compiler_types.number;
	parameter_types[1] = ra_roadsnap_compiler_types.number;
	np_Compiler_insert_function_cstr(compiler, "support",
					 ra_roadsnap_compiler_types.support,
					 parameter_types, parameter_types+2,
					 0, 0,
					 ra_roadsnap_function_support);

	parameter_types[0] = ra_roadsnap_compiler_types.filter_exp;
	np_Compiler_insert_function_cstr(compiler, "filter",
					 ra_roadsnap_compiler_types.filter,
					 parameter_types, parameter_types+1,
					 0, 0,
					 ra_roadsnap_function_filter);

	parameter_types[0] = ra_roadsnap_compiler_types.config;
	parameter_types[1] = ra_roadsnap_compiler_types.filter;
	np_Compiler_insert_function_cstr(compiler, ".",
					 ra_roadsnap_compiler_types.config,
					 parameter_types, parameter_types+2,
					 0, 0,
					 ra_roadsnap_function_config_filter);

	parameter_types[0] = ra_roadsnap_compiler_types.config;
	parameter_types[1] = ra_roadsnap_compiler_types.locates;
	np_Compiler_insert_function_cstr(compiler, ".",
					 ra_roadsnap_compiler_types.config,
					 parameter_types, parameter_types+2,
					 0, 0,
					 ra_roadsnap_function_config_locates);

	parameter_types[0] = ra_roadsnap_compiler_types.config;
	parameter_types[1] = ra_roadsnap_compiler_types.k;
	np_Compiler_insert_function_cstr(compiler, ".",
					 ra_roadsnap_compiler_types.config,
					 parameter_types, parameter_types+2,
					 0, 0,
					 ra_roadsnap_function_config_k);

	parameter_types[0] = ra_roadsnap_compiler_types.config;
	parameter_types[1] = ra_roadsnap_compiler_types.format;
	np_Compiler_insert_function_cstr(compiler, ".",
					 ra_roadsnap_compiler_types.config,
					 parameter_types, parameter_types+2,
					 0, 0,
					 ra_roadsnap_function_config_format);

	parameter_types[0] = ra_roadsnap_compiler_types.config;
	parameter_types[1] = ra_roadsnap_compiler_types.order;
	np_Compiler_insert_function_cstr(compiler, ".",
					 ra_roadsnap_compiler_types.config,
					 parameter_types, parameter_types+2,
					 0, 0,
					 ra_roadsnap_function_config_order);

	parameter_types[0] = ra_roadsnap_compiler_types.config;
	parameter_types[1] = ra_roadsnap_compiler_types.radius;
	np_Compiler_insert_function_cstr(compiler, ".",
					 ra_roadsnap_compiler_types.config,
					 parameter_types, parameter_types+2,
					 0, 0,
					 ra_roadsnap_function_config_radius);


	parameter_types[0] = ra_roadsnap_compiler_types.config;
	parameter_types[1] = ra_roadsnap_compiler_types.support;
	np_Compiler_insert_function_cstr(compiler, ".",
					 ra_roadsnap_compiler_types.config,
					 parameter_types, parameter_types+2,
					 0, 0,
					 ra_roadsnap_function_config_support);

	// insert roadsnap variable
	static const char *roadsnap_cstr = "snap";
	ra_roadsnap_Config *default_config = (ra_roadsnap_Config*) np_Compiler_alloc(compiler, sizeof(ra_roadsnap_Config));
	*default_config = (ra_roadsnap_Config) {
		.radius = 100.0f, // meters
		.k=1000,
		.format=ra_roadsnap_FORMAT_TEXT,
		.locates = {.num_locates = 0, .locates = 0 },
		.filter = 0,
		.order = ra_roadsnap_ORDER_OBJECTS_LOCATES,
		.support = { .min = -1, .max = -1 }
	};
	np_Compiler_insert_variable(compiler, (char*) roadsnap_cstr, cstr_end((char*)roadsnap_cstr), ra_roadsnap_compiler_types.config, default_config);

	static const char *help_cstr = "help";
	ra_roadsnap_Help *default_help = (ra_roadsnap_Help*) np_Compiler_alloc(compiler, Max(8,sizeof(ra_roadsnap_Help)));
	np_Compiler_insert_variable(compiler, (char*) help_cstr, cstr_end((char*)help_cstr), ra_roadsnap_compiler_types.help,   default_help);
}

typedef struct {
	ra_roadsnap_FilterExp *root;
	ra_roadsnap_Support   support;
	rg_Graph              *graph;
} ra_service_roadsnap_FilterInfo;

static b8
ra_service_roadsnap_object_filter_exp(rg_Graph *graph, rg_Object *object, ra_roadsnap_FilterExp *exp)
{
	Assert(exp);
	if (exp->type == ra_roadsnap_FILTER_KEY) {
		rg_Tag *tags = rg_Ptr_Tag_get(&object->tags.begin);
		for (s32 i=0;i<object->tags.count;++i) {
			rg_String *key   = rg_Ptr_String_get(&tags[i].key);
			if (cstr_compare_memory(exp->key.begin, exp->key.end, &key->begin, &key->begin + key->length) == 0) {
				return 1;
			}
		}
		return 0;
	} else if (exp->type == ra_roadsnap_FILTER_VALUE) {
		rg_Tag *tags = rg_Ptr_Tag_get(&object->tags.begin);
		for (s32 i=0;i<object->tags.count;++i) {
			rg_String *value   = rg_Ptr_String_get(&tags[i].value);
			if (cstr_compare_memory(exp->value.begin, exp->value.end, &value->begin, &value->begin + value->length) == 0) {
				return 1;
			}
		}
		return 0;
	} else if (exp->type == ra_roadsnap_FILTER_KEY_VALUE) {
		rg_Tag *tags = rg_Ptr_Tag_get(&object->tags.begin);
		for (s32 i=0;i<object->tags.count;++i) {
			rg_String *key   = rg_Ptr_String_get(&tags[i].key);
			rg_String *value = rg_Ptr_String_get(&tags[i].value);
			if (cstr_compare_memory(exp->key.begin, exp->key.end, &key->begin, &key->begin + key->length) == 0 &&
			    cstr_compare_memory(exp->value.begin, exp->value.end, &value->begin, &value->begin + value->length) == 0) {
				return 1;
			}
		}
		return 0;
	} else if (exp->type == ra_roadsnap_FILTER_AND) {
		return ra_service_roadsnap_object_filter_exp(graph, object, exp->left)
			&& ra_service_roadsnap_object_filter_exp(graph, object, exp->right);
	} else if (exp->type == ra_roadsnap_FILTER_OR) {
		return ra_service_roadsnap_object_filter_exp(graph, object, exp->left)
			|| ra_service_roadsnap_object_filter_exp(graph, object, exp->right);
	} else if (exp->type == ra_roadsnap_FILTER_NOT) {
		return !ra_service_roadsnap_object_filter_exp(graph, object, exp->left);
	}
	Assert(0 && "not implemented");
	return 0;
}

static b8
ra_service_roadsnap_node_filter_exp(rg_Graph *graph, rg_Locate *locate, ra_roadsnap_FilterExp *exp, ra_roadsnap_Support support)
{
	if (exp == 0) {
		if (support.min <= locate->num_objects) {
			if (support.max < 0) {
				return 1;
			} else if (locate->num_objects <= support.max) {
				return 1;
			} else {
				return 0;
			}
		} else {
			return 0;
		}
	}
	s32 count = 0;
	for (s32 i=0;i<locate->num_objects;++i) {
		rg_Object *object = rg_Locate_get_object(locate, i);
		if (ra_service_roadsnap_object_filter_exp(graph, object, exp)) {
			++count;
			// note that count is at least 1 at this point
			if (count >= support.min && support.max == -1) {
				return 1;
			} else if (support.max >= 0 && count > support.max) {
				return 0;
			}
		}
	}
	// there are count objects satisfying the filter in this locate.
	if (count == 0 || count < support.min) {
		return 0;
	} else if (count <= support.max) {
		return 1;
	} else {
		return 0;
	}
}

rg_NODE_FILTER_CALLBACK(ra_service_roadsnap_node_filter)
{
	rg_Graph              *graph  = ((ra_service_roadsnap_FilterInfo*) data)->graph;
	ra_roadsnap_FilterExp *root   = ((ra_service_roadsnap_FilterInfo*) data)->root;
	ra_roadsnap_Support   support = ((ra_service_roadsnap_FilterInfo*) data)->support;
	return ra_service_roadsnap_node_filter_exp(graph, locate, root, support);
}

//
// Roadnap http server
//

#define ra_service_snap_PRINT_RESULT_BUFFER_SIZE Megabytes(64)
#define ra_service_snap_PRINT_HEADER_BUFFER_SIZE Kilobytes(4)
#define ra_service_snap_COMPILER_BUFFER_SIZE     Megabytes(64)

typedef struct {
	BilinearAllocator      allocator;
	np_Compiler            compiler;
	np_CompilerCheckpoint  compiler_checkpoint;
	nt_Tokenizer           tokenizer;
	np_Parser              parser;
	Print                  print_header;
	Print                  print_result;
	// @todo replace with http2
	// http_Channel           http_channel;
	pt_TCP_Socket          *socket;
} ra_QueryBuffers;

typedef struct {
	Request                                      *request;
	rg_Graph                                     *graph;
	ra_QueryBuffers                 *buffers;
	u32                                          num_buffers;
} ra_service_snap_Info;

global_variable ra_service_snap_Info ra_service_snap_info;

// static
// http_HEADER_FIELD_CALLBACK(ra_service_snap_header_field_callback)
// {
// }

typedef struct {
	s32       rank; /* 0-based */
	f32       distance;
	rg_Locate *locate;
} ra_service_snap_RankedLocate;

typedef struct ra_service_snap_ObjRankedLocate {
	ra_service_snap_RankedLocate           *ranked_locate;
	struct ra_service_snap_ObjRankedLocate *next;
} ra_service_snap_ObjRankedLocate;

typedef struct {
	rg_Object       *object;
	ra_service_snap_ObjRankedLocate *list; // singly linked list
	b8              processed;
} ra_service_snap_Obj;

/*
 * Invert the aggregation from locates/objects to objects/locates
 * Returns 1 on success and 0 if not enough memory is available
 * Fills in the objects and allocator.
 */
static b8
ra_service_snap_aggregate_locates_by_objects(rg_Graph *graph, rg_Heap *heap, ra_roadsnap_FilterExp *filter,
		LinearAllocator *allocator, aatree_Tree *objects)
{
	LinearAllocator_clear(allocator);
	aatree_Tree_clear(objects);

	rg_HeapItem *end = heap->begin-1;
	rg_HeapItem *it  = heap->end-1;
	s64 num_locates  = heap->end - heap->begin;
	u64 index = 0;
	while (it != end) {
		rg_Locate *locate = (rg_Locate*) it->data;
		ra_service_snap_RankedLocate *ranked_locate = (ra_service_snap_RankedLocate*)
			LinearAllocator_alloc_if_available(allocator, sizeof(ra_service_snap_RankedLocate));
		if (!ranked_locate)
			return 0;
		*ranked_locate = (ra_service_snap_RankedLocate) { .rank=num_locates-index, .distance=-it->value, .locate=locate };
		++index;
		for (s32 i=0;i<locate->num_objects;++i) {
			rg_Object *object = rg_Locate_get_object(locate, i);

			if (filter) {
				if (!ra_service_roadsnap_object_filter_exp(graph, object, filter))
					continue;
			}

			s32 status = 0;
			aatree_Node *node = aatree_Tree_insert(objects, (u64) object, 0, &status);
			if (!node) {
				Assert(status == aatree_INSERT_FULL);
				return 0;
			}

			if (status == aatree_INSERT_OK) {
				ra_service_snap_Obj *obj = (ra_service_snap_Obj*) LinearAllocator_alloc_if_available(allocator, sizeof(ra_service_snap_Obj));
				if (!obj)
					return 0;
				*obj= (ra_service_snap_Obj) { .object = object, .list = 0, .processed = 0 };
				node->data = obj;
			}
			ra_service_snap_ObjRankedLocate *obj_ranked_locate = (ra_service_snap_ObjRankedLocate*)
				LinearAllocator_alloc_if_available(allocator, sizeof(ra_service_snap_ObjRankedLocate));
			if (!obj_ranked_locate)
				return 0;

			ra_service_snap_Obj *obj = (ra_service_snap_Obj*) node->data;
			*obj_ranked_locate = (ra_service_snap_ObjRankedLocate) { .ranked_locate = ranked_locate, .next = obj->list };
			obj->list = obj_ranked_locate;
		}
		--it;
	}
	return 1;
}

#define ra_PrintStack_CAPACITY 10

typedef struct {
	char  *stack[ra_PrintStack_CAPACITY];
	s32   num_items;
	char  *level_text;
	char  *line_feed;
	Print *print;
} ra_PrintStack;

static void
ra_PrintStack_init(ra_PrintStack *self, Print *print, char *level_text, char *line_feed)
{
	self->num_items = 0;
	self->print = print;
	self->level_text = level_text;
	self->line_feed = line_feed;
}

static inline void
ra_PrintStack_margin(ra_PrintStack *self)
{
	for (s32 i=0;i<self->num_items;++i) {
		print_cstr(self->print, self->level_text);
	}
}

static void
ra_PrintStack_print(ra_PrintStack *self, char *text)
{
	if (self->print->begin < self->print->end)
		print_cstr(self->print, self->line_feed);
	ra_PrintStack_margin(self);
	print_cstr(self->print, text);
}

static void
ra_PrintStack_append_cstr(ra_PrintStack *self, char *text)
{
	print_cstr(self->print, text);
}

static void
ra_PrintStack_append_str(ra_PrintStack *self, char *begin, char *end)
{
	print_str(self->print, begin, end);
}

static void
ra_PrintStack_align(ra_PrintStack *self, s32 len, s32 alignment, char sep)
{
	print_align(self->print, len, alignment, sep);
}

static void
ra_PrintStack_push(ra_PrintStack *self, char *open_text, char *close_text)
{
	Assert(self->num_items < ra_PrintStack_CAPACITY);
	if (open_text)
		ra_PrintStack_print(self, open_text);
	self->stack[self->num_items] = close_text;
	++self->num_items;
}

static inline void
ra_PrintStack_pop(ra_PrintStack *self)
{
	Assert(self->num_items > 0);
	--self->num_items;
	if (self->stack[self->num_items]) {
		ra_PrintStack_print(self, "");
		print_cstr(self->print, self->stack[self->num_items]);
	}
}

#define ra_PrintStack_push_formatted(self, close_text, open_text_format, ...) \
	ra_PrintStack_print((self), ""); \
	print_format((self)->print, open_text_format, __VA_ARGS__); \
	(self)->stack[(self)->num_items] = close_text; \
	++(self)->num_items;

#define ra_PrintStack_print_formatted(self, text_format, ...) \
	ra_PrintStack_print((self), ""); \
	print_format((self)->print, text_format, __VA_ARGS__);




static void
ra_solve_snap_query(rg_Graph *graph, MemoryBlock text, ra_QueryBuffers *buffer)
{
	Print *print_result = &buffer->print_result;
	Print *print_header = &buffer->print_header;

	/* reset compiler/parser memory*/
	np_Compiler_goto_checkpoint(&buffer->compiler, buffer->compiler_checkpoint);
	np_Compiler_clear_error_log(&buffer->compiler);

	/* point tokenizer to text */
	nt_Tokenizer_reset_text(&buffer->tokenizer, text.begin, text.end);
	np_Parser_reset(&buffer->parser);

	/* create AST */
	b8 ok = np_Parser_run(&buffer->parser);

	if (!ok) {
		print_cstr(print_result, "Syntax Error on Query\n");
		print_str(print_result, buffer->parser.log.begin, buffer->parser.log.end);

		print_cstr(print_header, "HTTP/1.1 400 Syntax Error\r\n");
		print_cstr(print_header, "Content-Type: text/plain\r\n");
		print_format(print_header, "Content-Length: %lld\r\n", print_length(print_result));
		print_cstr(print_header, "\r\n");

		output_(print_result);
		return;
	}

	/* compile AST */
	// np_Compiler_reduce(np_Compiler *self, np_AST_Node* node, char *text_begin, char *text_end)
	np_TypeValue last_statement = np_Compiler_reduce(&buffer->compiler, buffer->parser.ast_first, text.begin, text.end);

	if (!buffer->compiler.reduce.success) {
		print_cstr(print_result, "Compiler Error on Query\n");
		print_str(print_result, buffer->compiler.reduce.log.begin, buffer->compiler.reduce.log.end);

		print_cstr(print_header, "HTTP/1.1 400 Syntax Error\r\n");
		print_cstr(print_header, "Content-Type: text/plain\r\n");
		print_format(print_header, "Content-Length: %lld\r\n", print_length(print_result));
		print_cstr(print_header, "\r\n");

		output_(print_result);
		return;
	}

	if (last_statement.type_id == ra_roadsnap_compiler_types.help || last_statement.type_id == np_TYPE_UNDEFINED) {
		print_clear(print_result);
		print_cstr(print_result, ra_service_snap_api_doc);
		print_clear(print_header);
		print_cstr(print_header, "HTTP/1.1 200 Ok\n");
		print_cstr(print_header, "Content-Type: text/plain\r\n");
		print_format(print_header, "Content-Length: %lld\r\n", print_length(print_result));
		print_cstr(print_header, "\r\n");
		return;
	}

	if (last_statement.type_id != ra_roadsnap_compiler_types.config) {
		print_cstr(print_header, "HTTP/1.1 400 Compiled to Invalid Type\r\n\r\n");
		return;
	}

	ra_roadsnap_Config *config = (ra_roadsnap_Config*) last_statement.value;

	u64 heap_size = config->k * sizeof(rg_HeapItem);
	if (heap_size > BilinearAllocator_free_space(&buffer->allocator)) {
		print_cstr(print_header, "HTTP/1.1 400 Not Enough Memory for Heap\r\n\r\n");
		return;
	}

	/* prepare heap to collect results */
	rg_HeapItem *heap_begin = (rg_HeapItem*) BilinearAllocator_alloc_left(&buffer->allocator, heap_size);
	rg_HeapItem *heap_end   = heap_begin + config->k;
	rg_Heap heap;

	ra_service_roadsnap_FilterInfo filter_info = { .graph = graph, .root = config->filter,
		.support = {.min = config->support.min, .max=config->support.max } };
	rg_LocateFilterCallback *filter_callback = ra_service_roadsnap_node_filter;
	// if (config->filter) {
	// 	filter_callback = ra_service_roadsnap_node_filter;
	// }

	//
	// @TODO(llins) enable radius range
	// Currently only .r(max_radius) is available
	// Include .r(min_radius, max_radius)
	//

	// use the free space on buffer->allocator to store objects
	struct {
		LinearAllocator allocator;
		aatree_Tree     objects;
	} order_by_objects;

	// use the remaining of the available memory to aggregate
	// resulting locates into objects
	{
		MemoryBlock freemem   = MemoryBlock_aligned(BilinearAllocator_free_memblock(&buffer->allocator), 8);
		MemoryBlock freemem_0 = MemoryBlock_partition_part(freemem, 0, 2);
		MemoryBlock freemem_1 = MemoryBlock_partition_part(freemem, 1, 2);

		aatree_Node *begin = (aatree_Node*) freemem_0.begin;
		aatree_Node *end   = begin + (freemem_0.end - freemem_0.begin)/sizeof(aatree_Node);
		aatree_Tree_init(&order_by_objects.objects, begin, end);

		LinearAllocator_init(&order_by_objects.allocator, freemem_1.begin, freemem_1.begin, freemem_1.end);
	}


	print_clear(print_result);

	ra_PrintStack print_stack;
	switch (config->format) {
		case ra_roadsnap_FORMAT_TEXT:
			{
				ra_PrintStack_init(&print_stack, print_result, "............", "\n");
			} break;
		case ra_roadsnap_FORMAT_XML:
			{
				ra_PrintStack_init(&print_stack, print_result, "\t", "\n");
			} break;
		case ra_roadsnap_FORMAT_JSON:
			{
				ra_PrintStack_init(&print_stack, print_result, "\t", "\n");
			} break;
		case ra_roadsnap_FORMAT_HTML:
			{
				ra_PrintStack_init(&print_stack, print_result, "...........", "<br>\n");
			} break;
	}


	if (config->format == ra_roadsnap_FORMAT_TEXT
			|| config->format == ra_roadsnap_FORMAT_XML
			|| config->format == ra_roadsnap_FORMAT_HTML
			|| config->format == ra_roadsnap_FORMAT_JSON) {

		// ------ print -----
		switch (config->format) {
			case ra_roadsnap_FORMAT_TEXT:
				break;
			case ra_roadsnap_FORMAT_XML:
				{
					ra_PrintStack_push(&print_stack, "<result>", "</result>");
				} break;
				break;
			case ra_roadsnap_FORMAT_JSON:
				{
					ra_PrintStack_push(&print_stack, "[", "]");
				} break;
			case ra_roadsnap_FORMAT_HTML:
				{
					ra_PrintStack_push(&print_stack,
							"<html><head><style>"
							"body {font-family: Courier, monospace; font-size: 13px}"
							"</style></head><body><b>RESULT</b>",
							"</body></html>");
				} break;
		}
		// ------ print -----

		for (s32 locate_index=0;locate_index<config->locates.num_locates;++locate_index) {

			rg_Heap_init(&heap, heap_begin, heap_end);
			ra_roadsnap_LatLon *latlon = config->locates.locates + locate_index;
			rg_Graph_nearest_neighbors(graph,
						   latlon->lat, latlon->lon, config->radius, &heap,
						   filter_callback, &filter_info);

			// if order is input / objects / locates
			// collect all the objects from the locates
			// in the order they come
			rg_Heap_final_sort(&heap);

			// insert all the objects
			if (config->order == ra_roadsnap_ORDER_OBJECTS_LOCATES || config->order == ra_roadsnap_ORDER_OBJECTS_ALL_LOCATES) {

				// create an inverted hierarchy from locates/objects
				// to objects/locates
				b8 ok = ra_service_snap_aggregate_locates_by_objects(graph, &heap, config->filter,
						&order_by_objects.allocator, &order_by_objects.objects);
				if (!ok) {
					goto out_of_memory;
				}

				// ------ print -----
				switch (config->format) {
					case ra_roadsnap_FORMAT_TEXT:
						{
							ra_PrintStack_push_formatted(&print_stack, 0, "[%08d] input lat/lon: %10.6f %10.6f", locate_index+1, latlon->lat, latlon->lon);
						} break;
					case ra_roadsnap_FORMAT_XML:
						{
							ra_PrintStack_push_formatted(&print_stack, "</input>", "<input order=\"%d\" lat=\"%.6f\" lon=\"%.6f\">", locate_index+1, latlon->lat, latlon->lon);
							// print_format(print_result, "\n<input order=\"%d\" lat=\"%.6f\" lon=\"%.6f\">", (locate_index+1), latlon->lat, latlon->lon);
						} break;
					case ra_roadsnap_FORMAT_JSON:
						{
							if (locate_index > 0)
								ra_PrintStack_append_cstr(&print_stack, ",");
							ra_PrintStack_push(&print_stack, "{", "}");
							ra_PrintStack_print_formatted(&print_stack, "\"type\":\"input\", \"order\":%d, \"lat\":%f, \"lon\":%f,", locate_index+1, latlon->lat, latlon->lon);
							ra_PrintStack_push_formatted(&print_stack, "]", "\"objects\":[", (locate_index+1), latlon->lat, latlon->lon);
						} break;
					case ra_roadsnap_FORMAT_HTML:
						{
							ra_PrintStack_push_formatted(&print_stack, 0, "[%08d] Input Locate lat/lon: "
									"<a href=\"https://www.openstreetmap.org/search?query=%10.6f,%10.6f\">%10.6f %10.6f</a> "
									"(<a href=\"http://www.maps.google.com/maps?q=%10.6f,%10.6f\">Google Maps</a>)",
									(locate_index+1), latlon->lat, latlon->lon, latlon->lat, latlon->lon, latlon->lat, latlon->lon);

						} break;
				}
				// ------ print -----

				rg_HeapItem *it  = heap.begin;
				rg_HeapItem *end = heap.end;
				u64 index = 0;
				while (it != end) {
					rg_Locate *locate = (rg_Locate*) it->data;
					for (s32 i=0;i<locate->num_objects;++i) {
						rg_Object *object = rg_Locate_get_object(locate, i);
						aatree_Node *node = aatree_Tree_find(&order_by_objects.objects, (u64) object);
						if (!node)
							continue;
						ra_service_snap_Obj *obj = (ra_service_snap_Obj*) node->data;
						if (obj->processed)
							continue;
						++index;
						obj->processed = 1;


						// ------ print -----
						switch (config->format) {
							case ra_roadsnap_FORMAT_TEXT:
								{
									ra_PrintStack_push_formatted(&print_stack, 0, "[%08d] object id: %llu", index, latlon->lat, latlon->lon);
								} break;
							case ra_roadsnap_FORMAT_XML:
								{
									ra_PrintStack_push_formatted(&print_stack, "</object>", "<object order=\"%d\" id=\"%llu\">", index, object->id);
								} break;
							case ra_roadsnap_FORMAT_JSON:
								{
									if (index > 1)
										ra_PrintStack_append_cstr(&print_stack, ", ");
									ra_PrintStack_push(&print_stack, "{", "}");
									ra_PrintStack_print_formatted(&print_stack, "\"type\":\"object\", \"order\":%d, \"id\":\"%llu\",", index, object->id);
									ra_PrintStack_push(&print_stack, "\"tags\":{", "}");
// 									ra_PrintStack_print_formatted(&print_stack, "}", "\"type\":\"object\", \"order\":%d, \"id\":\"%llu\", \n\t\t\t\t\"tags\":{", index, object->id);
								} break;
							case ra_roadsnap_FORMAT_HTML:
								{
									ra_PrintStack_push_formatted(&print_stack, 0, "[%08d] object id: <a href=\"https://www.openstreetmap.org/way/%llu\">%llu</a>",
											index, object->id, object->id);
								} break;
						}
						// ------ print -----

						rg_Tag *tags = rg_Ptr_Tag_get(&object->tags.begin);
						for (s32 i=0;i<object->tags.count;++i) {
							rg_String *key   = rg_Ptr_String_get(&tags[i].key);
							rg_String *value = rg_Ptr_String_get(&tags[i].value);


							// ------ print -----
							switch (config->format) {
								case ra_roadsnap_FORMAT_TEXT:
									{
										ra_PrintStack_print(&print_stack, "");
										ra_PrintStack_append_str(&print_stack, &key->begin, &key->begin + key->length);
										ra_PrintStack_align(&print_stack, 40, -1, ' ');
										ra_PrintStack_append_str(&print_stack, &value->begin, &value->begin + value->length);
									} break;
								case ra_roadsnap_FORMAT_XML:
									{
										ra_PrintStack_print(&print_stack, "<tag k=\"");
										ra_PrintStack_append_str(&print_stack, &key->begin, &key->begin + key->length);
										ra_PrintStack_append_cstr(&print_stack, "\" v=\"");
										ra_PrintStack_append_str(&print_stack, &value->begin, &value->begin + value->length);
										ra_PrintStack_append_cstr(&print_stack, "\"/>");
									} break;
								case ra_roadsnap_FORMAT_JSON:
									{
										if (i > 0)
											ra_PrintStack_append_cstr(&print_stack, ",");
										ra_PrintStack_print(&print_stack, "\"");
										ra_PrintStack_append_str(&print_stack, &key->begin, &key->begin + key->length);
										ra_PrintStack_append_cstr(&print_stack, "\":\"");
										ra_PrintStack_append_str(&print_stack, &value->begin, &value->begin + value->length);
										ra_PrintStack_append_cstr(&print_stack, "\"");
									} break;
								case ra_roadsnap_FORMAT_HTML:
									{
										ra_PrintStack_print(&print_stack, "");
										ra_PrintStack_append_str(&print_stack, &key->begin, &key->begin + key->length);
										ra_PrintStack_align(&print_stack, 40, -1, '.');
										ra_PrintStack_append_str(&print_stack, &value->begin, &value->begin + value->length);
									} break;
							}
							// ------ print -----

						}


						// ------ print -----
						switch (config->format) {
							case ra_roadsnap_FORMAT_TEXT:
								{
									// ra_PrintStack_push(&print_stack, 0, 0);
								} break;
							case ra_roadsnap_FORMAT_XML:
								{
									ra_PrintStack_push(&print_stack, "<locates>", "</locates>");
								} break;
							case ra_roadsnap_FORMAT_JSON:
								{
									ra_PrintStack_pop(&print_stack);
									ra_PrintStack_append_cstr(&print_stack, ",");
									ra_PrintStack_push(&print_stack, "\"locates\":[", "]");
								} break;
							case ra_roadsnap_FORMAT_HTML:
								{
									// ra_PrintStack_push(&print_stack, 0, 0);
								} break;
						}
						// ------ print -----


						if (config->order == ra_roadsnap_ORDER_OBJECTS_LOCATES) {

							// TODO(llins): include locates
							ra_service_snap_ObjRankedLocate *orl = obj->list;
							s32 orl_num = 0;
							while (orl) {
								++orl_num;

								// ------ print -----
								switch (config->format) {
								case ra_roadsnap_FORMAT_TEXT:
									{
										ra_PrintStack_print_formatted(&print_stack, "[%03d] locate id: %-22llu lat/lon: %10.6f %10.6f rank: %5d dist: %8.1fm",
													      orl_num,
													      orl->ranked_locate->locate->id,
													      orl->ranked_locate->locate->lat,
													      orl->ranked_locate->locate->lon,
													      orl->ranked_locate->rank,
													      orl->ranked_locate->distance
													     );
									} break;
								case ra_roadsnap_FORMAT_XML:
									{
										ra_PrintStack_print_formatted(&print_stack, "<locate index=\"%d\" id=\"%llu\" lat=\"%f\" lon=\"%f\" rank=\"%d\" dist=\"%f\"/>",
													      orl_num,
													      orl->ranked_locate->locate->id,
													      orl->ranked_locate->locate->lat,
													      orl->ranked_locate->locate->lon,
													      orl->ranked_locate->rank,
													      orl->ranked_locate->distance
													     );
									} break;
								case ra_roadsnap_FORMAT_JSON:
									{
										if (orl_num > 1)
											ra_PrintStack_append_cstr(&print_stack, ", ");
										ra_PrintStack_print_formatted(&print_stack, "{ \"type\":\"locate\", \"index\":%d, \"id\":\"%llu\", \"lat\":%f, \"lon\":%f, \"rank\":%d, \"dist\":%f }",
													      orl_num,
													      orl->ranked_locate->locate->id,
													      orl->ranked_locate->locate->lat,
													      orl->ranked_locate->locate->lon,
													      orl->ranked_locate->rank,
													      orl->ranked_locate->distance
													     );
									} break;
								case ra_roadsnap_FORMAT_HTML:
									{
										ra_PrintStack_print_formatted(&print_stack,
													      "[%03d] locate id: <a href=\"https://www.openstreetmap.org/node/%llu\">%llu</a>"
													      "  dist: %8.2fm  rank: %5d"
													      " lat/lon: <a href=\"https://www.openstreetmap.org/search?query=%f,%f\">%10.6f %10.6f</a>"
													      "(<a href=\"http://www.maps.google.com/maps?q=%f,%f\">Google Maps</a>)",
													      orl_num,
													      orl->ranked_locate->locate->id,
													      orl->ranked_locate->locate->id,
													      orl->ranked_locate->distance,
													      orl->ranked_locate->rank,
													      orl->ranked_locate->locate->lat,
													      orl->ranked_locate->locate->lon,
													      orl->ranked_locate->locate->lat,
													      orl->ranked_locate->locate->lon,
													      orl->ranked_locate->locate->lat,
													      orl->ranked_locate->locate->lon);
									} break;
								}
								// ------ print -----

								orl = orl->next;
							}

						} else if (config->order == ra_roadsnap_ORDER_OBJECTS_ALL_LOCATES) {

							// TODO(llins): include locates
							rg_Object *raw_obj = obj->object;

							s32 loc_order = 0;
							rg_Ptr_Locate *it_loc = rg_Object_get_locates_begin(raw_obj);
							rg_Ptr_Locate *it_loc_end = it_loc + raw_obj->num_locates;
							while (it_loc != it_loc_end) {
								rg_Locate *loc = rg_Ptr_Locate_get(it_loc);
								++loc_order;

								// ------ print -----
								switch (config->format) {
								case ra_roadsnap_FORMAT_TEXT:
									{
										ra_PrintStack_print_formatted(&print_stack, "[%03d] locate id: %-22llu lat/lon: %10.6f %10.6f",
													      loc_order,
													      loc->id,
													      loc->lat,
													      loc->lon
													     );
									} break;
								case ra_roadsnap_FORMAT_XML:
									{
										ra_PrintStack_print_formatted(&print_stack, "<locate index=\"%d\" id=\"%llu\" lat=\"%f\" lon=\"%f\" />",
													      loc_order,
													      loc->id,
													      loc->lat,
													      loc->lon
													     );
									} break;
								case ra_roadsnap_FORMAT_JSON:
									{
										if (loc_order > 1)
											ra_PrintStack_append_cstr(&print_stack, ", ");
										ra_PrintStack_print_formatted(&print_stack, "{ \"type\":\"locate\", \"index\":%d, \"id\":\"%llu\", \"lat\":%f, \"lon\":%f }",
													      loc_order,
													      loc->id,
													      loc->lat,
													      loc->lon
													     );
									} break;
								case ra_roadsnap_FORMAT_HTML:
									{
										ra_PrintStack_print_formatted(&print_stack,
													      "[%03d] locate id: <a href=\"https://www.openstreetmap.org/node/%llu\">%llu</a>"
													      " lat/lon: <a href=\"https://www.openstreetmap.org/search?query=%f,%f\">%10.6f %10.6f</a>"
													      "(<a href=\"http://www.maps.google.com/maps?q=%f,%f\">Google Maps</a>)",
													      loc_order,
													      loc->id,
													      loc->id,
													      loc->lat,
													      loc->lon,
													      loc->lat,
													      loc->lon,
													      loc->lat);
									} break;
								}
								// ------ print -----

								++it_loc;
							}
						} // end objects_all ordering

						// ------ print -----
						ra_PrintStack_pop(&print_stack);
						switch (config->format) {
							case ra_roadsnap_FORMAT_TEXT:
								{
								} break;
							case ra_roadsnap_FORMAT_XML:
								{
									ra_PrintStack_pop(&print_stack);
								} break;
							case ra_roadsnap_FORMAT_JSON:
								{
									ra_PrintStack_pop(&print_stack);
								} break;
							case ra_roadsnap_FORMAT_HTML:
								{
								} break;
						}
						// ------ print -----


					}
					++it;
				}

				// ------ print -----
				ra_PrintStack_pop(&print_stack);
				switch (config->format) {
					case ra_roadsnap_FORMAT_TEXT:
						{
						} break;
					case ra_roadsnap_FORMAT_XML:
						{
						} break;
					case ra_roadsnap_FORMAT_JSON:
						{
							ra_PrintStack_pop(&print_stack);
						} break;
					case ra_roadsnap_FORMAT_HTML:
						{
						} break;
				}
				// ------ print -----

			} // objects/locates
			else if (config->order == ra_roadsnap_ORDER_LOCATES_OBJECTS) {

				// ------ print -----
				switch (config->format) {
					case ra_roadsnap_FORMAT_TEXT:
						{
							ra_PrintStack_push_formatted(&print_stack, 0, "[%08d] input lat/lon: %10.6f %10.6f", (locate_index+1), latlon->lat, latlon->lon);
						} break;
					case ra_roadsnap_FORMAT_XML:
						{
							ra_PrintStack_push_formatted(&print_stack, "</input>", "<input order=\"%d\" lat=\"%.6f\" lon=\"%.6f\">", (locate_index+1), latlon->lat, latlon->lon);
						} break;
					case ra_roadsnap_FORMAT_JSON:
						{
							if (locate_index > 0)
								ra_PrintStack_append_cstr(&print_stack, ",");
							ra_PrintStack_push_formatted(&print_stack, " ] }", "{ \"type\":\"input\", \"order\":%d, \"lat\":%f, \"lon\":%f, \"locates\":[", (locate_index+1), latlon->lat, latlon->lon);
						} break;
					case ra_roadsnap_FORMAT_HTML:
						{
							ra_PrintStack_push_formatted(&print_stack, 0, "[%08d] Input Locate lat/lon: "
									"<a href=\"https://www.openstreetmap.org/search?query=%f,%f\">%10.6f %10.6f</a> "
									"(<a href=\"http://www.maps.google.com/maps?q=%f,%f\">Google Maps</a>)",
									(locate_index+1),
									latlon->lat, latlon->lon,
									latlon->lat, latlon->lon,
									latlon->lat, latlon->lon);
						} break;

				}
				// ------ print -----

				rg_HeapItem *it  = heap.begin;
				rg_HeapItem *end = heap.end;
				u64 index = 0;
				while (it != end) {
					++index;
					rg_Locate *node = (rg_Locate*) it->data;


					u64 num_valid_objects = 0;
					for (s32 i=0;i<node->num_objects;++i) {
						rg_Object *object = rg_Locate_get_object(node, i);

						//
						// check if this object is one of the valid ones
						// by design there should be at least one since
						// the node above was chosen
						//
						if (config->filter) {
							if (!ra_service_roadsnap_object_filter_exp(graph, object, config->filter))
								continue;
						}

						++num_valid_objects;
						if (num_valid_objects == 1) {

							// ------ print -----
							switch (config->format) {
							case ra_roadsnap_FORMAT_TEXT:
								{
									ra_PrintStack_push_formatted(&print_stack, 0, "[%08d] locate id: %llu  dist: %8.2fm  lat/lon: %10.6f %10.6f",
												     index, node->id, -it->value, node->lat, node->lon);
								} break;
							case ra_roadsnap_FORMAT_XML:
								{
									ra_PrintStack_push_formatted(&print_stack, "</locate>", "<locate order=\"%d\" id=\"%llu\" dist=\"%f\" lat=\"%.6f\" lon=\"%.6f\">",
												     index, node->id, -it->value, node->lat, node->lon);
								} break;
							case ra_roadsnap_FORMAT_JSON:
								{
									if (index > 1)
										ra_PrintStack_append_cstr(&print_stack, ",");
									ra_PrintStack_push_formatted(&print_stack, "] }", "{ \"type\":\"locate\", \"order\":%d, \"id\":\"%llu\", \"dist\":%f, \"lat\":%f, \"lon\":%f,\"objects\":[",
												     index, node->id, -it->value, node->lat, node->lon);
								} break;
							case ra_roadsnap_FORMAT_HTML:
								{
									ra_PrintStack_push_formatted(&print_stack,
												     0,
												     "[%08d] locate id: <a href=\"https://www.openstreetmap.org/node/%llu\">%llu</a>"
												     "  dist: %8.2fm  "
												     " lat/lon: <a href=\"https://www.openstreetmap.org/search?query=%f,%f\">%10.6f %10.6f</a>"
												     "(<a href=\"http://www.maps.google.com/maps?q=%f,%f\">Google Maps</a>)",
												     index,
												     node->id, node->id,
												     -it->value,
												     node->lat, node->lon,
												     node->lat, node->lon,
												     node->lat, node->lon);
								} break;
							}
							// ------ print -----

						}

						// ------ print -----
						switch (config->format) {
							case ra_roadsnap_FORMAT_TEXT:
								{
									ra_PrintStack_push_formatted(&print_stack,0,"[%08d] object id: %llu", num_valid_objects, object->id);
								} break;
							case ra_roadsnap_FORMAT_XML:
								{
									ra_PrintStack_push_formatted(&print_stack,"</object>","<object order=\"%d\" id=\"%llu\">", num_valid_objects, object->id);
								} break;
							case ra_roadsnap_FORMAT_JSON:
								{
									if (num_valid_objects > 1)
										ra_PrintStack_append_cstr(&print_stack, ", ");
									ra_PrintStack_push_formatted(&print_stack, "} }", "{ \"type\":\"object\", \"order\":%d, \"id\":\"%llu\", \"tags\": {",
											num_valid_objects, object->id);
								} break;
							case ra_roadsnap_FORMAT_HTML:
								{
									ra_PrintStack_push_formatted(&print_stack, 0,"[%08d] object id: <a href=\"https://www.openstreetmap.org/way/%llu\">%llu</a>",
											num_valid_objects, object->id, object->id);
								} break;
						}
						// ------ print -----


						rg_Tag *tags = rg_Ptr_Tag_get(&object->tags.begin);
						for (s32 i=0;i<object->tags.count;++i) {
							rg_String *key   = rg_Ptr_String_get(&tags[i].key);
							rg_String *value = rg_Ptr_String_get(&tags[i].value);

							// ------ print -----
							switch (config->format) {
								case ra_roadsnap_FORMAT_TEXT:
									{
										ra_PrintStack_print(&print_stack, "");
										ra_PrintStack_append_str(&print_stack, &key->begin, &key->begin + key->length);
										ra_PrintStack_align(&print_stack, 40, -1, ' ');
										ra_PrintStack_append_str(&print_stack, &value->begin, &value->begin + value->length);
									} break;
								case ra_roadsnap_FORMAT_XML:
									{
										ra_PrintStack_print(&print_stack, "<tag k=\"");
										ra_PrintStack_append_str(&print_stack, &key->begin, &key->begin + key->length);
										ra_PrintStack_append_cstr(&print_stack, "\" v=\"");
										ra_PrintStack_append_str(&print_stack, &value->begin, &value->begin + value->length);
										ra_PrintStack_append_cstr(&print_stack, "\"/>");
									} break;
								case ra_roadsnap_FORMAT_JSON:
									{
										if (i > 0)
											ra_PrintStack_append_cstr(&print_stack, ",");
										ra_PrintStack_print(&print_stack, "\"");
										ra_PrintStack_append_str(&print_stack, &key->begin, &key->begin + key->length);
										ra_PrintStack_append_cstr(&print_stack, "\":\"");
										ra_PrintStack_append_str(&print_stack, &value->begin, &value->begin + value->length);
										ra_PrintStack_append_cstr(&print_stack, "\"");
									} break;
								case ra_roadsnap_FORMAT_HTML:
									{
										ra_PrintStack_print(&print_stack, "");
										ra_PrintStack_append_str(&print_stack, &key->begin, &key->begin + key->length);
										ra_PrintStack_align(&print_stack, 40, -1, ' ');
										ra_PrintStack_append_str(&print_stack, &value->begin, &value->begin + value->length);
									} break;
							}
							// ------ print -----
						}

						// ------ print -----
						ra_PrintStack_pop(&print_stack);
						switch (config->format) {
						case ra_roadsnap_FORMAT_TEXT:
							{
							} break;
						case ra_roadsnap_FORMAT_XML:
							{
							} break;
						case ra_roadsnap_FORMAT_JSON:
							{
							} break;
						case ra_roadsnap_FORMAT_HTML:
							{
							} break;
						}
						// ------ print -----

					} // loop objects

					if (num_valid_objects > 0) {
						// ------ print -----
						ra_PrintStack_pop(&print_stack);
						switch (config->format) {
						case ra_roadsnap_FORMAT_TEXT:
							{
							} break;
						case ra_roadsnap_FORMAT_XML:
							{
							} break;
						case ra_roadsnap_FORMAT_JSON:
							{
							} break;
						case ra_roadsnap_FORMAT_HTML:
							{
							} break;
						}
						// ------ print -----
					}

					++it;
				} // loop locates

				// ------ print -----
				ra_PrintStack_pop(&print_stack);
				switch (config->format) {
					case ra_roadsnap_FORMAT_TEXT:
						{
						} break;
					case ra_roadsnap_FORMAT_XML:
						{
						} break;
					case ra_roadsnap_FORMAT_JSON:
						{
						} break;
					case ra_roadsnap_FORMAT_HTML:
						{
						} break;
				}
				// ------ print -----

			} // locates/objects

		} // loop input

		// ------ print -----
		switch (config->format) {
			case ra_roadsnap_FORMAT_TEXT:
				break;
			case ra_roadsnap_FORMAT_XML:
				ra_PrintStack_pop(&print_stack);
				break;
			case ra_roadsnap_FORMAT_JSON:
				ra_PrintStack_pop(&print_stack);
				break;
			case ra_roadsnap_FORMAT_HTML:
				ra_PrintStack_pop(&print_stack);
				break;
		}
		// null terminate result
		print_char(print_stack.print, '\0');
		// ------ print -----
		goto ok;
out_of_memory:
		// header
		print_clear(print_result);
		print_cstr(print_result, "Out of Memory when trying to aggregate locates into objects\n");
		print_clear(print_header);
		print_cstr(print_header, "HTTP/1.1 400 Out of Memory\r\n");
		print_cstr(print_header, "Content-Type: text/plain\r\n");
		print_format(print_header, "Content-Length: %lld\r\n", print_length(print_result));
		print_cstr(print_header, "\r\n");
		return;
ok:
		// ------ print -----
		print_clear(print_header);
		print_cstr(print_header, "HTTP/1.1 200 OK\r\n");
		print_format(print_header, "Content-Length: %lld\r\n", print_length(print_result));
		switch (config->format) {
			case ra_roadsnap_FORMAT_TEXT:
				{
					print_cstr(print_header, "Content-Type: text/plain\r\n");
				} break;
			case ra_roadsnap_FORMAT_XML:
				{
					print_cstr(print_header, "Content-Type: text/xml\r\n");
				} break;
			case ra_roadsnap_FORMAT_JSON:
				{
					print_cstr(print_header, "Content-Type: application/json\r\n");
				} break;
			case ra_roadsnap_FORMAT_HTML:
				{
					print_cstr(print_header, "Content-Type: text/html\r\n");
				} break;
		}
		print_cstr(print_header, "\r\n");
		// ------ print -----
	} else if (config->format == ra_roadsnap_FORMAT_LEAFLET) {

		print_cstr(print_result,"<!DOCTYPE html>");
		print_cstr(print_result,"<html>");
		print_cstr(print_result,"<head>");
		print_cstr(print_result,"<title>Leaflet format</title>");
		print_cstr(print_result,"<meta charset=\"utf-8\" />");
		print_cstr(print_result,"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">");
		print_cstr(print_result,"<link rel=\"shortcut icon\" type=\"image/x-icon\" href=\"docs/images/favicon.ico\" />");
		//
		// old version of leaflet
		// print_cstr(print_result,"<link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.0.3/dist/leaflet.css\" />");
		// print_cstr(print_result,"<script src=\"https://unpkg.com/leaflet@1.0.3/dist/leaflet.js\"></script>");
		//
		print_cstr(print_result,"<link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.2.0/dist/leaflet.css\" />");
		print_cstr(print_result,"<script src=\"https://unpkg.com/leaflet@1.2.0/dist/leaflet.js\"></script>");
		// allows us to get full page maps
                print_cstr(print_result,"<style>");
                print_cstr(print_result,"body {");
                print_cstr(print_result,"padding: 0;");
                print_cstr(print_result,"margin: 0;");
                print_cstr(print_result,"}");
                print_cstr(print_result,"html, body, #mapid {");
                print_cstr(print_result,"height: 100%;");
                print_cstr(print_result,"width: 100%;");
                print_cstr(print_result,"}");
                print_cstr(print_result,"</style>");
		print_cstr(print_result,"</head>");
		// body
		print_cstr(print_result,"<body>");
                print_cstr(print_result,"<style>");
                print_cstr(print_result,".custom-popup .leaflet-popup-tip,");
                print_cstr(print_result,".custom-popup .leaflet-popup-content-wrapper {");
                print_cstr(print_result,"width:600px;");
                print_cstr(print_result,"display:inline-block;");
                print_cstr(print_result,"white-space:nowrap;");
                print_cstr(print_result,"}");
                print_cstr(print_result,".leaflet-container {");
                print_cstr(print_result,"font-family: Courier, monospace; font-size: 12px;");
                print_cstr(print_result,"}");
                print_cstr(print_result,"</style>");
		print_cstr(print_result,"<div class=\"custom-popup \" id=\"mapid\"></div>");
		print_cstr(print_result,"<script>");
                // center map on first input lat,long
                ra_roadsnap_LatLon *latlon = config->locates.locates;
                print_format(print_result,"var mymap = L.map('mapid').setView([%10.6f, %10.6f], 16);", latlon->lat, latlon->lon);
                print_cstr(print_result,"L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {");
                print_cstr(print_result,"maxZoom: 18,");
                print_cstr(print_result,"}).addTo(mymap);");
		// define red marker
                print_cstr(print_result,"var redIcon = new L.Icon({");
                print_cstr(print_result,"iconUrl: 'https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',");
                print_cstr(print_result,"shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',");
                print_cstr(print_result,"iconSize: [25, 41],");
                print_cstr(print_result,"iconAnchor: [12, 41],");
                print_cstr(print_result,"popupAnchor: [1, -34],");
                print_cstr(print_result,"shadowSize: [41, 41]");
                print_cstr(print_result,"});");

		// for each input location...
		for (s32 locate_index=0;locate_index<config->locates.num_locates;++locate_index) {
                    rg_Heap_init(&heap, heap_begin, heap_end);
                    latlon = config->locates.locates + locate_index;

                    rg_Graph_nearest_neighbors(ra_service_snap_info.graph,
                                               latlon->lat, latlon->lon, config->radius, &heap,
                                               filter_callback, &filter_info);
                    rg_Heap_final_sort(&heap);
		    // place red circle on input location with correct radius
                    print_format(print_result,"L.circle([%10.6f, %10.6f], %f, {", latlon->lat, latlon->lon, config->radius);
                    print_cstr(print_result,"color: 'red',");
                    print_cstr(print_result,"fillColor: '#f03',");
                    print_cstr(print_result,"fillOpacity: 0.15");
                    print_cstr(print_result,"}).addTo(mymap);");
		    // place transparent red marker in center of circle
                    print_format(print_result,"L.marker([%10.6f, %10.6f], {icon: redIcon,opacity:0.50}).addTo(mymap)", latlon->lat, latlon->lon);
                    print_format(print_result,".bindPopup(\"Input Locate %03d: %10.6f, %10.6f\");", (locate_index+1), latlon->lat, latlon->lon);

                    rg_HeapItem *it  = heap.begin;
                    rg_HeapItem *end = heap.end;
                    u64 index = 0;
		    // for each object within radius of input location...
                    while (it != end) {
                        ++index;
                        rg_Locate *node = (rg_Locate*) it->data;
		 	// place blue marker with lat,long and distance from input location point
                        print_format(print_result,"L.marker([%10.6f, %10.6f]).addTo(mymap)", node->lat, node->lon);
                        print_cstr(print_result,".bindPopup(\""); // start of bindPopup
                        print_format(print_result, "[%03d] OSM node id: %llu<br>", index, node->id);
                        print_format(print_result, " dist: %8.2fm lat/lon: %10.6f, %10.6f<br>", -it->value, node->lat, node->lon);

                        s32 way_index = -1;
                        for (s32 i=0;i<node->num_objects;++i) {
                            ++way_index;
                            rg_Object *way = rg_Locate_get_object(node, i);
                            //
                            // check if this way is one of the valid ones
                            // by design there should be at least one since
                            // the node above was chosen
                            //
                            if (config->filter) {
                                if (!ra_service_roadsnap_object_filter_exp(graph, way, config->filter))
                                    continue;
                            }

                            print_format(print_result,"... [%03d] OSM highway id: %llu<br>",
                                         way_index+1, way->id);
                            rg_Tag *tags = rg_Ptr_Tag_get(&way->tags.begin);
                            for (s32 i=0;i<way->tags.count;++i) {
                                rg_String *key   = rg_Ptr_String_get(&tags[i].key);
                                rg_String *value = rg_Ptr_String_get(&tags[i].value);
                                print_cstr(print_result, "...... ");
                                print_str(print_result,&key->begin, &key->begin + key->length);
                                print_align(print_result, 32, -1, '.');
                                print_str(print_result,&value->begin, &value->begin + value->length);
                                print_cstr(print_result,"<br>");
                            }
                        }

                        print_cstr(print_result,"\");"); // end of bindPopup
                        ++it;
                    }
		}
		print_cstr(print_result,"</script>");
		print_cstr(print_result, "\n</body>");
		print_cstr(print_result, "\n</html>");
		print_char(print_result, '\0');

		// header
		print_clear(print_header);
		print_cstr(print_header, "HTTP/1.1 200 OK\n");
		print_cstr(print_header, "Content-Type: text/html\r\n");
		print_format(print_header, "Content-Length: %lld\r\n", print_length(print_result));
		print_cstr(print_header, "\r\n");
	}

}



/*
BEGIN_DOC_STRING ra_service_snap_api_doc
snap                                                                  __VERSION__
====

API to retrieve *objects* that are "nearby" a certain query *locate*.


    http://<server>:<port>/<path-to-entry-point>/snap.loc(40.7162398,-74.0055749).max(100).radius(1000)


The url above retrieves the closest 100 *locates* in the database relative to
the given lat/lon. The resulting *locates* need to be within a *radius* of 1000
meters. The *objects* associated with these *locates*, which usually are the
"things" an application is really interested, are also retrieved.

The supported options of a *snap* request are the following

    .loc(*[LAT,LON])
	 List of query locates lat/lon pairs. Note that we can submit
	 multiple lat/lon pairs per request.

    .max(N)
         Find the closest N locates in the database with at least one object
	 matching the filter. Default is 1000.

    .radius(R)
	 Find locates within R meters from the query locates. Default is 100m.

    .format(S)
         S is either 'text' (default) , 'xml', 'json', 'html', 'leaflet'

    .order(S)
         S is either 'objects' (default), 'locates', 'objects_all'
	 if 'objects_all', all locates of an objects preserving order are brought

    .support(MIN,MAX)
         Only consider locates with number of filtered objects between MIN and MAX.
	 Use -1 to indicate either no min or no max constraint. For example
	 .support(2,-1) means all locates with at least two filtered objects.

    .filter(FILTER)
	 Only consider objects that satisfy the FILTER constraints

	 .k(S)
		Filter only the objects that has a key-value pair with key == S

	 .v(S)
		Filter only the objects that has a key-value pair with value == S

	 .kv(S,T)
		Filter only the objects that has a key-value pair with key == S and value == T

	 F1 + F2
		OR two filters

	 F1 * F2
		AND two filters

	 not(F)
		complement of filter F


EXAMPLES

In the following examples we assuma a snap database of Open Street Map
objects.

If we are just interested in the closest *locate* that is associated with
at least one *object* tagged with the key 'highway', we append a *k* filter:

    /snap.loc(40.7162398,-74.0055749).radius(1000).max(1).filter(k('highway'))

In case we want to the closest 5 *locates* that are associated *objects* tagged
with a 'highway','residential' key,value pair we use

    /snap.loc(40.7162398,-74.0055749).radius(1000).max(5)
        .filter(kv('highway','residential'))

To relax the previous filter to also accept *objects* which are 'highway'
and 'primary' we use the '+' (or) binary operator

    /snap.loc(40.7162398,-74.0055749).radius(1000).max(5)
        .filter(kv('highway','residential')+kv('highway','primary'))

To restrict the previous filter to only accept *objects* which have
10007 as their zipcode, we use the '*' (and) operator

    /snap.loc(40.7162398,-74.0055749).radius(1000).max(5)
        .filter((kv('highway','residential')+kv('highway','primary'))
             *(kv('tiger:zip_left','10007')+kv('tiger:zip_right','10007')))

Locates with two or more objects that are highways of type
either primary, secondary, residential, local within 500 meters
of the query lat/lon

    /snap.loc(40.7162398,-74.0055749).radius(500).max(1000).format('leaflet')
        .filter(kv('highway','primary')+kv('highway','secondary')
            +kv('highway','residential')+kv('highway','local'))
 	.support(2,-1).order('locates')

TODO

    Add API to obtain full description of objects and locates by ID

    GET /objects.format('text').ids(1323132,1232331);
    GET /locates.format('xml').ids(1323132,1232331);

END_DOC_STRING
*/

// @todo replace with http2

#if 0
static
http_REQUEST_LINE_CALLBACK(ra_service_snap_request_line_callback)
{
	u64 index = (u64) channel->user_data;
	ra_QueryBuffers *buffer = ra_service_snap_info.buffers + index;

	Print *print_result = &buffer->print_result;
	Print *print_header = &buffer->print_header;

	print_clear(print_header);
	print_clear(print_result);

	pt_TCP_Socket *socket = buffer->socket;

	/* check if method is GET */
	if (pt_compare_memory_cstr(method_begin, method_end, "GET")) {
		print_cstr(print_header, "HTTP/1.1 400 Invalid Request (not GET)\r\n\r\n");
		platform.tcp_write(socket, print_header->begin, print_header->end - print_header->begin);
		return;
	}

	/*
	 * @TODO(llins): two passes on the request data could
	 * be avoided if tokenizer was aware of the %23 notation
	 * of url request targets
	 */
	MemoryBlock text = { .begin = request_target_begin+1, .end = request_target_end };
	text = ut_convert_uri_to_ascii(text);

	ra_solve_snap_query(ra_service_snap_info.graph, text, buffer);

	/* write down result on tcp port */
	platform.tcp_write(socket, print_header->begin, print_length(print_header));
	platform.tcp_write(socket, print_result->begin, print_length(print_result));
}


static
PLATFORM_TCP_CALLBACK(ra_service_snap_request_handler)
{
	u64 index = platform.get_thread_index();

	Assert(index < ra_service_snap_info.num_buffers);
	ra_service_snap_info.buffers[index].socket = socket;

	/* push data into http channel */
	http_Channel_receive_data(&ra_service_snap_info.buffers[index].http_channel, buffer, length);
}
#endif

/*
BEGIN_DOC_STRING ra_service_snap_doc
Ver:   __VERSION__
Usage: nanocube snap SNAPFILE PORT [-threads=N] [-http_buffer_size=S]
Start an http server based on a snap database.

    -threads=N
        Number of threads to process requests. For now each request
	is assigned to one thread and resolved there sequentially.
	In the future we could have a large request being solved by
	multiple threads.

    -http_buffer_size=S
        The default is 16M. This number bounds the max request size.

END_DOC_STRING
*/

static void
ra_service_snap(Request *request)
{
	// @todo @uncomment
#if 0
	Print      *print   = request->print;
	op_Options *options = &request->options;

	if (op_Options_find_cstr(options,"-help") || op_Options_num_positioned_parameters(options) == 1) {
		print_clear(print);
		print_cstr(print, ra_service_snap_doc);
		output_( print);
		return;
	}

	u64 num_threads = 1;
	if (op_Options_find_cstr(options,"-threads")) {
		if (!op_Options_named_u64_cstr(options,"-threads",0,&num_threads)) {
			log_cstr_("[serve] incorrect usage of options: -threads=<num-threads>\n");
			return;
		}
	}
	if (num_threads < 1)
		num_threads = 1;

	u64 port = 0;
	MemoryBlock input_filename  = { .begin=0, .end=0 };
	if (!op_Options_str(options, 1, &input_filename) ||
	    !op_Options_u64(options, 2, &port)) {
		log_cstr_("[ra_service_roadnsap_http_server] invalid arguments\n");
		log_cstr_("[ra_service_roadnsap_http_server] usage: snap <roadmap> <port> [-threads=<num-threads>] [-buffer=<max-get-message-size>] [-timeout=<kill-any-query-that-takes-too-much-time>]\n");
		return;
	}

	s64 http_buffer_size = Megabytes(16);
	if (op_Options_find_cstr(options,"-http_buffer_size")) {
		MemoryBlock st;
		if (!op_Options_named_str_cstr(options,"-http_buffer_size",0,&st)) {
			ra_service_create_snap_error_cstr(request, "invalid memory value on -http_buffer_size (default: 16M)");
			return;
		} else {
			http_buffer_size = ut_parse_storage_size(st.begin, st.end);
			if (http_buffer_size < Megabytes(4)) {
				ra_service_create_snap_error_cstr(request, "invalid memory value on -http_buffer_size (needs to be at least 4M)");
				return;
			}
		}
	}

	//
	// could do it in the memory map way
	// add to the platform a way to map a file
	//
	pt_MappedFile mapped_file = platform.open_mmap_file(input_filename.begin, input_filename.end, 1, 0);
	if (!mapped_file.mapped) {
		log_cstr_("[ra_service_roadnsap_http_server] couldn't open of the road database.\n");
		return;
	}

	al_Allocator* allocator = (al_Allocator*) mapped_file.begin;
	rg_Graph *graph = (rg_Graph*) al_Ptr_char_get(&allocator->root_p);

	/* Basic Allocator */
	BasicAllocator basic_allocator;
	BasicAllocator_init(&basic_allocator);

	ra_service_snap_info = (ra_service_snap_Info) {
		.request = request,
		.graph = graph,
		.num_buffers = num_threads,
		.buffers = (ra_QueryBuffers*)
			BasicAllocator_alloc(&basic_allocator,
					     num_threads * sizeof(ra_QueryBuffers), 3)
	};

	for (s32 i=0;i<num_threads;++i) {
		ra_QueryBuffers *buffer = ra_service_snap_info.buffers + i;

		// initialize http channels
		char *http_buffer_begin = (char*) BasicAllocator_alloc(&basic_allocator, http_buffer_size, 3);
		char *http_buffer_end   = http_buffer_begin + http_buffer_size;

		/* initialize http channel memory */
		http_Channel_init(&buffer->http_channel,
				  http_buffer_begin,
				  http_buffer_end,
				  ra_service_snap_request_line_callback,
				  ra_service_snap_header_field_callback,
				  (void*) ((u64) i) ); /* storing an index into a pointer */

		/* */
		char *print_result_begin = (char*) BasicAllocator_alloc(&basic_allocator, ra_service_snap_PRINT_RESULT_BUFFER_SIZE, 3);
		char *print_result_end = print_result_begin + ra_service_snap_PRINT_RESULT_BUFFER_SIZE;
		char *print_header_begin = (char*) BasicAllocator_alloc(&basic_allocator, ra_service_snap_PRINT_HEADER_BUFFER_SIZE, 3);
		char *print_header_end = print_header_begin + ra_service_snap_PRINT_HEADER_BUFFER_SIZE;

		print_init(&buffer->print_result, print_result_begin, print_result_end);
		print_init(&buffer->print_header, print_header_begin, print_header_end);

		/* compiler linear allocator */
		char *compiler_buffer_begin = (char*) BasicAllocator_alloc(&basic_allocator, ra_service_snap_COMPILER_BUFFER_SIZE, 3);
		char *compiler_buffer_end   = compiler_buffer_begin + ra_service_snap_COMPILER_BUFFER_SIZE;
		BilinearAllocator_init(&buffer->allocator, compiler_buffer_begin, compiler_buffer_end);

		/* compiler */
		np_Compiler_init(&buffer->compiler, &buffer->allocator);
		ra_roadsnap_init_query_compiler(&buffer->compiler);
		buffer->compiler_checkpoint = np_Compiler_checkpoint(&buffer->compiler);

		/* tokenizer & parser */
		np_initialize_tokenizer(&buffer->tokenizer, 0, 0);
		np_Parser_init(&buffer->parser, &buffer->tokenizer, &buffer->allocator);
	}

	// create tcp infra-structure
	pt_TCP tcp = platform.tcp_create();
	Assert(tcp.handle);

	// open up serve port
	pt_TCP_Feedback feedback;
	platform.tcp_serve(tcp, port, 0, ra_service_snap_request_handler, &feedback);

	// do one iteration of even processing (should register the port server requested above)
	platform.tcp_process_events(tcp, 0);

	if (feedback.status != pt_TCP_SOCKET_OK) {
		return;
	}

	pt_WorkQueue *work_queue = 0;
	if (num_threads > 1) {
		work_queue = platform.work_queue_create(num_threads);
		// log message to differentiate from sequential server
		print_clear(print);
		print_format(print,"[ra_service_roadnsap_http_server] threads %llu\n", num_threads);
		output_( print);
	} else {
		print_clear(print);
		print_format(print,"[ra_service_roadnsap_http_server] single threaded\n");
		output_( print);
	}

	while (!global_app_state->interrupted) {
		platform.tcp_process_events(tcp, work_queue);
	}

	/* TODO(llins): somehow there should be a way to signal the server to stop */
	platform.work_queue_destroy(work_queue);

	platform.close_mmap_file(&mapped_file);
	BasicAllocator_free_all(&basic_allocator);
#endif
}



/*
BEGIN_DOC_STRING ra_service_snap_cli_doc
Ver:   __VERSION__
Usage: nanocube snap-cli SNAPFILE QUERY
Run a snap query through the command line interface. Note that
the query syntax is the same as the web server API.
Example:
    nanocube snap-cli -o=out.xml db.roadmap "{snap.loc(40.7162398,-74.0055749).format('text').radius(1000).max(100)}"
Options:
    -o=FILE
	Output file. If not defined goes to stderr
    -help-api
        To print the query API
END_DOC_STRING
*/

static void
ra_service_snap_cli(Request *request)
{
#if 0
	Print      *print   = request->print;
	op_Options *options = &request->options;

	if (op_Options_find_cstr(options,"-help") || op_Options_num_positioned_parameters(options) == 1) {
		print_clear(print);
		print_cstr(print, ra_service_snap_cli_doc);
		output_( print);
		return;
	}

	if (op_Options_find_cstr(options,"-help-api")) {
		print_clear(print);
		print_cstr(print, ra_service_snap_api_doc);
		output_( print);
		return;
	}

	pt_File output_file = { .handle = 0 };
	MemoryBlock output_file_name = { .begin = 0, .end = 0 };
	if (op_Options_find_cstr(options,"-o")) {
		if (!op_Options_named_str_cstr(options,"-o",0,&output_file_name)) {
			ra_service_create_snap_error_cstr(request, "invalid -o=FILE option");
			return;
		} else {
			output_file = platform.open_write_file(output_file_name.begin, output_file_name.end);
			if (!output_file.open) {
				ra_service_create_snap_error_cstr(request, "invalid -o=FILE option");
				return;
			}
		}
	}

	MemoryBlock input_filename  = { .begin=0, .end=0 };
	MemoryBlock query           = { .begin=0, .end=0 };
	if (!op_Options_str(options, 1, &input_filename) ||
	    !op_Options_str(options, 2, &query)) {
		log_cstr_("[ra_service_snap_cli] invalid arguments\n");
		log_cstr_("[ra_service_snap_cli] usage: snap <roadmap> <query> [-threads=<num-threads>] [-buffer=<max-get-message-size>] [-timeout=<kill-any-query-that-takes-too-much-time>]\n");
		return;
	}

	//
	// could do it in the memory map way
	// add to the platform a way to map a file
	//
	pt_MappedFile mapped_file = platform.open_mmap_file(input_filename.begin, input_filename.end, 1, 0);
	if (!mapped_file.mapped) {
		log_cstr_("[ra_service_snap_cli] couldn't open of the road database.\n");
		return;
	}

	al_Allocator* allocator = (al_Allocator*) mapped_file.begin;
	rg_Graph *graph = (rg_Graph*) al_Ptr_char_get(&allocator->root_p);

	/* Basic Allocator */
	BasicAllocator basic_allocator;
	BasicAllocator_init(&basic_allocator);

	/* query buffer */
	ra_QueryBuffers buffer_storage;
	ra_QueryBuffers *buffer = &buffer_storage;

	char *print_result_begin = (char*) BasicAllocator_alloc(&basic_allocator, ra_service_snap_PRINT_RESULT_BUFFER_SIZE, 3);
	char *print_result_end = print_result_begin + ra_service_snap_PRINT_RESULT_BUFFER_SIZE;
	char *print_header_begin = (char*) BasicAllocator_alloc(&basic_allocator, ra_service_snap_PRINT_HEADER_BUFFER_SIZE, 3);
	char *print_header_end = print_header_begin + ra_service_snap_PRINT_HEADER_BUFFER_SIZE;

	print_init(&buffer->print_result, print_result_begin, print_result_end);
	print_init(&buffer->print_header, print_header_begin, print_header_end);
	Print *print_result = &buffer->print_result;
	Print *print_header = &buffer->print_header;

	/* compiler linear allocator */
	char *compiler_buffer_begin = (char*) BasicAllocator_alloc(&basic_allocator, ra_service_snap_COMPILER_BUFFER_SIZE, 3);
	char *compiler_buffer_end   = compiler_buffer_begin + ra_service_snap_COMPILER_BUFFER_SIZE;
	BilinearAllocator_init(&buffer->allocator, compiler_buffer_begin, compiler_buffer_end);

	/* compiler */
	np_Compiler_init(&buffer->compiler, &buffer->allocator);
	ra_roadsnap_init_query_compiler(&buffer->compiler);
	buffer->compiler_checkpoint = np_Compiler_checkpoint(&buffer->compiler);

	/* tokenizer & parser */
	np_initialize_tokenizer(&buffer->tokenizer, 0, 0);
	np_Parser_init(&buffer->parser, &buffer->tokenizer, &buffer->allocator);

	/* solve the query */
	ra_solve_snap_query(graph, query, buffer);

	/* write down result on tcp port */
	if (output_file.handle) {
		platform.write_to_file(&output_file, print_header->begin, print_header->end);
		platform.write_to_file(&output_file, print_result->begin, print_result->end);
	} else {
		output_( print_header);
		output_( print_result);
	}

	platform.close_mmap_file(&mapped_file);
	BasicAllocator_free_all(&basic_allocator);
#endif
}

